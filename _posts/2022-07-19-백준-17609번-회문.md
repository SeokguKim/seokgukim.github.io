---
title: 백준 17069번 회문
layout: post
tags: [cpp]
---
### 문제 개요
> **문제**  
> 회문(回文) 또는 팰린드롬(palindrome)은 앞 뒤 방향으로 볼 때 같은 순서의 문자로 구성된 문자열을 말한다. 예를 들어 ‘abba’ ‘kayak’, ‘reviver’, ‘madam’은 모두 회문이다. 만일 그 자체는 회문이 아니지만 한 문자를 삭제하여 회문으로 만들 수 있는 문자열이라면 우리는 이런 문자열을 “유사회문”(pseudo palindrome)이라고 부른다. 예를 들어 ‘summuus’는 5번째나 혹은 6번째 문자 ‘u’를 제거하여 ‘summus’인 회문이 되므로 유사회문이다.  
> 여러분은 제시된 문자열을 분석하여 그것이 그 자체로 회문인지, 또는 한 문자를 삭제하면 회문이 되는 “유사회문”인지, 아니면 회문이나 유사회문도 아닌 일반 문자열인지를 판단해야 한다. 만일 문자열 그 자체로 회문이면 0, 유사회문이면 1, 그 외는 2를 출력해야 한다. 

> **입력**  
> 입력의 첫 줄에는 주어지는 문자열의 개수를 나타내는 정수 T(1 ≤ T ≤ 30)가 주어진다. 다음 줄부터 T개의 줄에 걸쳐 한 줄에 하나의 문자열이 입력으로 주어진다. 주어지는 문자열의 길이는 3 이상 100,000 이하이고, 영문 알파벳 소문자로만 이루어져 있다.

> **출력**  
> 각 문자열이 회문인지, 유사 회문인지, 둘 모두 해당되지 않는지를 판단하여 회문이면 0, 유사 회문이면 1, 둘 모두 아니면 2를 순서대로 한 줄에 하나씩 출력한다.

### 재귀만 잘 하자
시작과 끝을 잡고 점점 좁혀가면서 문자가 일치하는지 확인하면 된다.  
여기서 유사회문을 판별해야 하는 문제가 생기는데, 딱 하나만 빼서 회문인 경우이므로,  
어떤 지점에서 문자가 일치하지 않을 때 시작이나 끝 문자 중 하나를 빼서 진행시킨 결과가 회문에 해당하는 경우가 될 것이다.  
이는 재귀 구조로 나눈 다음 최솟값을 취하는 것으로 해결했다.
### 코드
```c++
#include <iostream>
using namespace std;

int N;
string s;

int chk(int l, int r, int remain) {//재귀 체크
    if (!remain || l > r) return 0;//2번째 문자가 제거되었거나 모든 범위를 탐색했으면 더 볼 필요가 없으니 0을 리턴하고 종료한다.
    if (s[l] != s[r]) return min(chk(l, r - 1, remain - 1), chk(l + 1, r, remain -1)) + 1;
    //해당 지점의 문자가 일치하지 않는다면 시작 문자와 끝 문자를 각각 제외한 값으로 돌려보고 1을 더한 값을 리턴
    return chk(l + 1, r - 1, remain);//일치한다면 범위를 좁혀 탐색
}

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin >> N;
    while (N--) {
        cin >> s;
        cout << chk(0, s.length() - 1, 2) << "\n";
    }
}
```
