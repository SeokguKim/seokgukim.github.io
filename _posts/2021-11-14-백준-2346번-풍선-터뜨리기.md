---
title: 백준 2346번 풍선 터뜨리기
layout: post
tag: [cpp]
---
### 문제 개요
> 1번부터 N번까지 N개의 풍선이 원형으로 놓여 있고. i번 풍선의 오른쪽에는 i+1번 풍선이 있고, 왼쪽에는 i-1번 풍선이 있다. 단, 1번 풍선의 왼쪽에 N번 풍선이 있고, N번 풍선의 오른쪽에 1번 풍선이 있다. 각 풍선 안에는 종이가 하나 들어있고, 종이에는 -N보다 크거나 같고, N보다 작거나 같은 정수가 하나 적혀있다. 이 풍선들을 다음과 같은 규칙으로 터뜨린다.
> 우선, 제일 처음에는 1번 풍선을 터뜨린다. 다음에는 풍선 안에 있는 종이를 꺼내어 그 종이에 적혀있는 값만큼 이동하여 다음 풍선을 터뜨린다. 양수가 적혀 있을 경우에는 오른쪽으로, 음수가 적혀 있을 때는 왼쪽으로 이동한다. 이동할 때에는 이미 터진 풍선은 빼고 이동한다.
> 예를 들어 다섯 개의 풍선 안에 차례로 3, 2, 1, -3, -1이 적혀 있었다고 하자. 이 경우 3이 적혀 있는 1번 풍선, -3이 적혀 있는 4번 풍선, -1이 적혀 있는 5번 풍선, 1이 적혀 있는 3번 풍선, 2가 적혀 있는 2번 풍선의 순서대로 터지게 된다.
> 
> 첫째 줄에 자연수 N(1 ≤ N ≤ 1,000)이 주어진다. 다음 줄에는 차례로 각 풍선 안의 종이에 적혀 있는 수가 주어진다. 종이에 0은 적혀있지 않다.
> 
> 첫째 줄에 터진 풍선의 번호를 차례로 나열한다.

### 덱을 이용해 돌려주자
덱을 이용해 왔다갔다 하면서 출력해주자. 적당히 하면 되는 문제.
### 코드
```c++
#include <iostream>
#include <deque>
using namespace std;

int N;//입력받을 풍선 개수
deque<pair<int,int>> dq;//풍선 정보 저장할 덱
int main() {	
	cin >> N;//N 입력받음
	for (int i = 1; i <= N; i++) {//N개만큼
		int a;//적힌 번호 정보를 받을 a
		cin >> a;//a 입력받음
		dq.push_back(make_pair(i, a));//덱에 현재 인덱스와 a값을 차례로 넣어줌
	}
	while (1) {//리턴문 만날 때까지 반복
		cout << dq.front().first << " ";//일단 맨 앞의 원소를 출력해준 뒤
		int a = dq.front().second;//적힌 번호 정보를 a에 저장
		dq.pop_front();//앞 원소 비워줌.이로써 덱 맨 앞 원소는 원본의 +1 위치, 맨 뒤는 원본의 -1 위치가 됨
		if (dq.empty()) return 0;//덱이 비면 리턴으로 강제종료
		if (a > 0) {//a가 양수면
			for (int i = 0; i < a - 1; i++) {//앞에서 a번째의 위치를 맨 앞으로 당겨와야 하므로, a - 1번만큼 실행
				dq.push_back(dq.front());//맨 앞 원소를 뒤로 보내고
				dq.pop_front();//앞 원소를 지워줌
			}
		}
		else {//a가 음수면
			for (int j = 0; j < (-a); j++) {//뒤에서 a번째의 위치를 맨 앞으로 당겨와야 하므로, -a 번만큼 실행
				dq.push_front(dq.back());//맨 뒤 원소를 앞으로 가져오고
				dq.pop_back();//뒤의 원소 지워줌
			}
		}
	}
}
```
### 해설
원형으로 된 풍선의 배치를 어떻게 생각하냐가 관건.  
문제에서 제시된 대로 맨 뒤의 원소가 -1 지점에 해당한다는걸 참고로 덱을 만들고 조작해서 풀어보자.  
