---
title: 백준 3665 최종 순위
layout: post
tags: [cpp]
---
### 문제 개요
> 올해 ACM-ICPC 대전 인터넷 예선에는 총 n개의 팀이 참가했다. 팀은 1번부터 n번까지 번호가 매겨져 있다. 놀랍게도 올해 참가하는 팀은 작년에 참가했던 팀과 동일하다.  
> 올해는 인터넷 예선 본부에서는 최종 순위를 발표하지 않기로 했다. 그 대신에 작년에 비해서 상대적인 순위가 바뀐 팀의 목록만 발표하려고 한다. (작년에는 순위를 발표했다) 예를 들어, 작년에 팀 13이 팀 6 보다 순위가 높았는데, 올해 팀 6이 팀 13보다 순위가 높다면, (6, 13)을 발표할 것이다.  
> 창영이는 이 정보만을 가지고 올해 최종 순위를 만들어보려고 한다. 작년 순위와 상대적인 순위가 바뀐 모든 팀의 목록이 주어졌을 때, 올해 순위를 만드는 프로그램을 작성하시오. 하지만, 본부에서 발표한 정보를 가지고 확실한 올해 순위를 만들 수 없는 경우가 있을 수도 있고, 일관성이 없는 잘못된 정보일 수도 있다. 이 두 경우도 모두 찾아내야 한다.
> 
> 첫째 줄에는 테스트 케이스의 개수가 주어진다. 테스트 케이스는 100개를 넘지 않는다. 각 테스트 케이스는 다음과 같이 이루어져 있다.
> - 팀의 수 n을 포함하고 있는 한 줄. (2 ≤ n ≤ 500)
> - n개의 정수 ti를 포함하고 있는 한 줄. (1 ≤ ti ≤ n) ti는 작년에 i등을 한 팀의 번호이다. 1등이 가장 성적이 높은 팀이다. 모든 ti는 서로 다르다.
> - 상대적인 등수가 바뀐 쌍의 수 m (0 ≤ m ≤ 25000)
> 
> 두 정수 ai와 bi를 포함하고 있는 m줄. (1 ≤ ai < bi ≤ n) 상대적인 등수가 바뀐 두 팀이 주어진다. 같은 쌍이 여러 번 발표되는 경우는 없다.
> 
> 각 테스트 케이스에 대해서 다음을 출력한다.
> 
> n개의 정수를 한 줄에 출력한다. 출력하는 숫자는 올해 순위이며, 1등팀부터 순서대로 출력한다. 만약, 확실한 순위를 찾을 수 없다면 "?"를 출력한다. 데이터에 일관성이 없어서 순위를 정할 수 없는 경우에는 "IMPOSSIBLE"을 출력한다.

### 위상 정렬을 해보자
일단 주어지는 최초의 입력 순서로 진입차수를 구상하고, 쿼리 정보를 더해 위상 정렬하는 식으로 생각해보자.  
중간에 사이클이 발생하면 IMPOSSIBLE, 동일한 차수가 2개 이상 존재해버리면 ?가 될 것이다.
### 코드
```c++
#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>
#include <memory.h>
using namespace std;

int T, N, M, order[501], od[501], deg[501];//order - 순위를 받을 배열, od - 각 팀의 순위, deg - 진입차수

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);

    cin >> T;
    while (T--) {//각 테스트 케이스에 대해
        cin >> N;
        vector<vector<int>> v(N + 1);//간선 벡터를 설정
        vector<int> no;//답 출력용 벡터
        queue<int> q;//큐
        memset(deg, 0, sizeof(deg));//진입차수는 초기화
        
        for (int i = 1; i <= N; i++) {//각 순위 입력에 대해
            cin >> order[i];//순위 배열에 받고
            od[order[i]] = i;//팀 번호에 해당하는 순위를 저장
            for (int j = 1; j < i; j++) {//이전까지의 순위 입력에 대해
                v[order[j]].push_back(order[i]), deg[order[i]]++;//간선과 진입차수 설정
            }
        }
        cin >> M;
        while (M--) {//쿼리 입력에 대해
            int a, b;
            cin >> a >> b;
            
            int *pro = nullptr, *post = nullptr;
            if (od[a] > od[b]) pro = &b, post = &a;
            else pro = &a, post = &b;
            //순위가 높은 것을 pro, 낮은 것을 post로 설정            
            auto it = find(v[*pro].begin(), v[*pro].end(), *post);//일단 정확히 높은 순위에서 낮은 순위로 가는 간선이 있는지 검색
            if (it != v[*pro].end()) v[*pro].erase(it), deg[*post]--;//있다면 지워주고 진입차수 처리
            v[*post].push_back(*pro);//낮은 순위에서 높은 순위로 가는 간선 설정
            deg[*pro]++;//높은 순위의 진입차수는 올려줌
        }

        for (int i = 1; i <= N; i++) if (!deg[order[i]])q.push(order[i]);//모든 노드를 훑으며 진입차수 0인 것을 큐에 삽입
        int fail = 1;//실패 변수(큐 크기). 최초는 1로 설정
        for (int i = 1; i <= N; i++) {//N개의 모든 노드를 다 돌때까지
            if (q.size() != 1) {//만약 큐가 비거나(사이클 발생, 데이터 일관성이 없음) 큐의 크기가 2를 넘어가면(동일한 진입차수가 복수 존재)
                fail = q.size();//실패 변수 설정
                break;//탈출
            }
            int x = q.front();//큐의 맨 앞 원소
            q.pop();//큐 날림
            no.push_back(x);//답 벡터에 삽입
            for (int j = 0; j < v[x].size(); j++) {//해당 지점의 간선을 탐색
                if (!(--deg[v[x][j]])) q.push(v[x][j]);//간선에 해당하는 진입차수를 갱신해 줬을때 들어갈 수 있게 되면 큐에 삽입
            }
        }
        if (fail == 1) for (int i : no) cout << i << " ";//실패 변수를 안 건드리고 왔다면 성공한 것이므로 답 벡터를 출력
        else if (!fail) cout << "IMPOSSIBLE";//실패 변수가 0이라면 데이터 일관성의 문제이므로 IMPOSSIBLE
        else cout << "?";//2 이상이면 확실한 순위가 없으므로 ?
        cout << "\n";
    }
}
```
### 여담
다 풀고서 코드 길이 줄여보겠다고 포인터를 쓰려 했는데, 자꾸 컴파일 에러가 났다.  
알고 보니 레퍼런스 기호를 포인터 기호로 착각하고 썼던게 원흉.  
기본적인 실수는 하지 말아야겠다.
