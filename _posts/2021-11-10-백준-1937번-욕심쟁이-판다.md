---
title: 백준 1937번 욕심쟁이 판다
layour: post
tags: [cpp]
---
### 문제 개요
> n × n의 크기의 대나무 숲이 있다. 욕심쟁이 판다는 어떤 지역에서 대나무를 먹기 시작한다. 그리고 그 곳의 대나무를 다 먹어 치우면 상, 하, 좌, 우 중 한 곳으로 이동을 한다. 그리고 또 그곳에서 대나무를 먹는다. 그런데 단 조건이 있다. 이 판다는 매우 욕심이 많아서 대나무를 먹고 자리를 옮기면 그 옮긴 지역에 그 전 지역보다 대나무가 많이 있어야 한다.
> 이 판다의 사육사는 이런 판다를 대나무 숲에 풀어 놓아야 하는데, 어떤 지점에 처음에 풀어 놓아야 하고, 어떤 곳으로 이동을 시켜야 판다가 최대한 많은 칸을 방문할 수 있는지 고민에 빠져 있다. 우리의 임무는 이 사육사를 도와주는 것이다. n × n 크기의 대나무 숲이 주어져 있을 때, 이 판다가 최대한 많은 칸을 이동하려면 어떤 경로를 통하여 움직여야 하는지 구하여라.
> 
> 첫째 줄에 대나무 숲의 크기 n(1 ≤ n ≤ 500)이 주어진다. 그리고 둘째 줄부터 n+1번째 줄까지 대나무 숲의 정보가 주어진다. 대나무 숲의 정보는 공백을 사이로 두고 각 지역의 대나무의 양이 정수 값으로 주어진다. 대나무의 양은 1,000,000보다 작거나 같은 자연수이다.
> 
> 첫째 줄에는 판다가 이동할 수 있는 칸의 수의 최댓값을 출력한다.

### 친절하다
경로 탐색 문제의 변형. 가능한 모든 경로를 탐색해 최적값을 찾아야 하는데,  
친절하게도 여기서 이전 것보다 큰 값을 가진 곳으로만 이동이 가능하므로, 사실상 방문 여부를 체크할 필요가 없다.
### 코드
```c++
#include <iostream>

using namespace std;

int N, ans;//숲 크기 입력받을 N과 답을 저장해둘 ans
int soop[501][501];//숲 정보를 저장할 배열
int iruk[501][501];//각 위치에 놓았을때의 최댓값을 저장할 배열
int mov[4][2] = { {-1,0},{1,0},{0,-1},{0,1} };//이동용 배열

int dfs(int r, int c) {//탐색 알고리즘
    if (iruk[r][c]) return iruk[r][c];//이미 처리가 되어 

    int max_cnt = 0;//일단 임시로 쓸 최대 이동값 변수

    for (int i = 0; i < 4; ++i) {//상하좌우로 이동해서
        int nx = r + mov[i][0], ny = c + mov[i][1];//좌표 수정
        if (0 < nx && nx <= N && 0 < ny && ny <= N) if (soop[nx][ny] > soop[r][c]) max_cnt = max(max_cnt, dfs(nx, ny));//좌표 이내에 있고 다음 값이 더 크면 다음 현재 위치로부터의 이동한 최대 이력과 다음 좌표에서의 이동 이력을 비교해 더 큰 걸 사용
    }
    return iruk[r][c] = max_cnt + 1;//다 돌았으면 현 위치까지 포함해 이동 가능한 위치의 최대값에 더해 반환하면서 이력에 저장해줌
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    //입출력 구문
    cin >> N;//크기 입력
    for (int i = 1; i <= N; i++) for (int j = 1; j <= N; j++) cin >> soop[i][j];//숲 입력 받아주기
    for (int i = 1; i <= N; i++) for (int j = 1; j <= N; j++) {
        dfs(i, j);//모든 좌표에 대해 탐색 실행하고
        ans = max(ans, iruk[i][j]);//해당 이력에 대해 최대값인지 여부 판별
    }
    cout << ans;//답 출력
}
```
### 해설
재귀형으로 탐색 함수를 만든다음 돌리면서, 그 이력을 배열에 저장해 호출 시 가져와 복잡도를 줄아도록 한다.
그 후 비교해주며 최대값 출력하면 된다.
