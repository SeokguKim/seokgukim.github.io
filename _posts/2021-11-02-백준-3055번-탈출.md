---
title: 백준 3055번 탈출
layout: post
tags: [cpp]
---
### 문제 개요
> 사악한 암흑의 군주 이민혁은 드디어 마법 구슬을 손에 넣었고, 그 능력을 실험해보기 위해 근처의 티떱숲에 홍수를 일으키려고 한다. 이 숲에는 고슴도치가 한 마리 살고 있다. 고슴도치는 제일 친한 친구인 비버의 굴로 가능한 빨리 도망가 홍수를 피하려고 한다.
> 티떱숲의 지도는 R행 C열로 이루어져 있다. 비어있는 곳은 '.'로 표시되어 있고, 물이 차있는 지역은 '&#42;', 돌은 'X'로 표시되어 있다. 비버의 굴은 'D'로, 고슴도치의 위치는 'S'로 나타내어져 있다.
> 매 분마다 고슴도치는 현재 있는 칸과 인접한 네 칸 중 하나로 이동할 수 있다. (위, 아래, 오른쪽, 왼쪽) 물도 매 분마다 비어있는 칸으로 확장한다. 물이 있는 칸과 인접해있는 비어있는 칸(적어도 한 변을 공유)은 물이 차게 된다. 물과 고슴도치는 돌을 통과할 수 없다. 또, 고슴도치는 물로 차있는 구역으로 이동할 수 없고, 물도 비버의 소굴로 이동할 수 없다.
> 티떱숲의 지도가 주어졌을 때, 고슴도치가 안전하게 비버의 굴로 이동하기 위해 필요한 최소 시간을 구하는 프로그램을 작성하시오.
> 고슴도치는 물이 찰 예정인 칸으로 이동할 수 없다. 즉, 다음 시간에 물이 찰 예정인 칸으로 고슴도치는 이동할 수 없다. 이동할 수 있으면 고슴도치가 물에 빠지기 때문이다. 
>
> 첫째 줄에 50보다 작거나 같은 자연수 R과 C가 주어진다.
> 다음 R개 줄에는 티떱숲의 지도가 주어지며, 문제에서 설명한 문자만 주어진다. 'D'와 'S'는 하나씩만 주어진다.
>
> 첫째 줄에 고슴도치가 비버의 굴로 이동할 수 있는 가장 빠른 시간을 출력한다. 만약, 안전하게 비버의 굴로 이동할 수 없다면, "KAKTUS"를 출력한다.

### 탐색 알고리즘인데 뭘 더 해야함
그냥 최소 시간만 출력하는 거면 일반적인 그래프 탐색 문제와 다를 바 없다. 하지만 물이 시간마다 차올라서 추가 연산을 해야 한다.
### 코드
```c++
#include <iostream>
#include <queue>
using namespace std;

int R, C;//숲 크기
int mov[4][2] = { {-1,0},{1,0},{0,-1},{0,1} };//이동에 쓰일 배열
char board[51][51];//숲의 정보를 저장할 배열
int hist[51][51];//히스토리 저장할 배열
queue<pair<int,int>> q, wq;//도치의 이동 작업을 실행할 q와 물이 차오를 작업을 실행알 wq

void flood() {//물이 차오르는걸 구현한 함수
	int a = wq.front().first, b = wq.front().second;//일단 큐의 맨 위의 페어 자료형으로부터 변수 가져옴
	for (int i = 0; i < 4; i++) {//각각 이동
		int aa = a + mov[i][0], bb = b + mov[i][1];//새 좌표
		if (board[aa][bb] == '.') {//빈 땅이면
			board[aa][bb] = '*';//물로 만들고
			wq.push(make_pair(aa,bb));//대기열에 추가
		}
	}
	wq.pop();//큐 맨 위 날림
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);
//입출력 원활히
	cin >> R >> C;
	for (int i = 1; i <= R; i++) cin >> &board[i][1];//배열에 char형으로 입력받음. 줄단위에 띄어쓰기가 안 되어있기에 포인터 써서 간단히
	for (int i = 1; i <= R; i++) for (int j = 1; j <= C; j++) {//검사
		if (board[i][j] == '*') wq.push(make_pair(i,j));//물이 있으면 물큐에 추가
		else if (board[i][j] == 'S') q.push(make_pair(i,j));//도치 하나 있는거 도치큐에 추가
	}
	while (!q.empty()) {//도치 이동 매커니즘
    //다음턴에 차는덴 못간다 = 물 차는건 1턴 빠르게 생각하자랑 대충 같은 말이니 물부터 채우고 시작
		int ws = wq.size();//일단 물큐 크기 정보를 받아 현 시간대에 일어나는 일만 처리
		while (ws--) flood();//홍수함수 돌리기
		int curs = q.size();//일단 도치큐 크기 정보를 받아 현 시간대에 일어나는 일만 처리
		while(curs--) {
			int x = q.front().first, y = q.front().second;//도치큐 맨 앞의 페어로부터 변수 받아오고
			q.pop();//큐 앞 날림
			for (int ii = 0; ii < 4; ii++) {//이동 매커니즘
				int xx = x + mov[ii][0], yy = y + mov[ii][1];//새 좌표
				if (board[xx][yy] == '.' && hist[xx][yy] ==  0) {//빈 땅이고 간 적이 없다면
					hist[xx][yy] = hist[x][y] + 1;//히스토리를 추가하면서
					q.push(make_pair(xx,yy));//큐에 신규 삽입
				}
				else if (board[xx][yy] == 'D') {//도착지라면
					cout << hist[x][y] + 1;//현 좌표의 히스토리 + 1이 거기까지 가는데의 시간이니 출력해주고
					return 0;//강제 종료
				}
			}
		}
	}
	cout << "KAKTUS";//만약 저 반복문 다 돌도록 함수 종료가 안 되고 여까지 오면 도치는 사망이니 이걸 출력
}
```
### 해설
일단 큐를 이용해 현 시점에 일어나는 일들을 처리해 가면서 보드를 업데이트 해주며 탐색을 하니 풀렸다.  
다음 턴에 물이 차오르는 곳은 못간다는 말은 그냥 물 차오르는걸 한 턴 당겨서 생각하념 되는 거였고,  
히스토리 배열을 만들어 간 곳은 이중 체크 안 하게 수정하니 되었다.
### 여담
처음에 귀찮아서 히스토리 검사를 안 넣었더니만 작업 수행량이 많아져서 메모리 초과로 꽤나 고생했다.  
