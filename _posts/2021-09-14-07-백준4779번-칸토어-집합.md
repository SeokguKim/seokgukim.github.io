---
title: 백준 4779번 칸토어 집합
layout: post
tags: [cpp]
---
### 문제 개요
> 칸토어 집합은 0과 1사이의 실수로 이루어진 집합으로, 구간 [0, 1]에서 시작해서 각 구간을 3등분하여 가운데 구간을 반복적으로 제외하는 방식으로 만든다.
> 전체 집합이 유한이라고 가정하고, 다음과 같은 과정을 통해서 칸토어 집합의 근사를 만들어보자.
> 1. -가 3N개 있는 문자열에서 시작한다.
> 2. 문자열을 3등분 한 뒤, 가운데 문자열을 공백으로 바꾼다. 이렇게 하면, 선(문자열) 2개가 남는다.
> 3. 이제 각 선(문자열)을 3등분 하고, 가운데 문자열을 공백으로 바꾼다. 이 과정은 모든 선의 길이가 1일때 까지 계속 한다.
>
>입력을 여러 줄로 이루어져 있다. 각 줄에 N이 주어진다. 파일의 끝에서 입력을 멈춘다. N은 0보다 크거나 같고, 12보다 작거나 같은 정수이다.
>
>입력으로 주어진 N에 대해서, 해당하는 칸토어 집합의 근사를 출력한다.

### 적당히 점화식만 넣으면 되는 문제
재귀로 풀라고 안내되어 있긴 한데, 그냥 적당히 점화식 넣으면 될 거 같아서 이렇게 했다.
### 코드
```c++
#include <iostream>

using namespace std;

int N;

int pow3(int mul) {//3의 거듭제곱 간단함수(어차피 제대로 만들 필요 없음)
	int res = 1;//초기값 1
	while (mul) {//mul이 0이 될때까지 3을 곱함
		res *= 3; mul--;
	}
	return res;//값 반환
}

int main()
{
	cin.tie(NULL); cout.tie(NULL);
	ios::sync_with_stdio(false);
	while (1) {
		cin >> N;
		if (cin.eof())break;//파일 끝 입력이 오면 탈출
		for (int i = 1; i <= pow3(N); i++) {//문자열 길이 = 3^N이므로 이런 범위
			bool flg = false;//일단 플래그
			for (int j = 1; j <= N; j++) if (i % pow3(j) > pow3(j - 1) && i % pow3(j) <= 2 * pow3(j - 1)) flg = true;//각 인덱스에 대해 N >= 1인 3^N으로 나눈 나머지가 3^N-1과 2×3^N-1 사이면 이놈은 공백
			if (flg) cout << " ";//조건 맞음 공백
			else cout << "-";//아님 하이픈
		}
		cout << endl;//줄바꿈
	}
}
```
### 해설
적당히 양의 정수에서만 돌아가는 3의 거듭제곱 함수를 만들어 범위 설정에 이용했다.  
조금 머리를 굴려보니 공백으로 표시되는 것들은 3^N으로 나눴을때 나머지가 3^N-1과 2×3^N-1이라는게 나왔으니 적당히 반복문 돌렸다.
### 여담
cin.eof()의 활용법을 제대로 몰라 여러번 빠꾸를 먹었다. 알고리즘 자체는 맞게 했는데 말이다.  
이것도 나중에 보니 재귀형으로 푼 다른 사람들에 비해 자원을 많이 썼다. 다음엔 더 잘해야지. 
