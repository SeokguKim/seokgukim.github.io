---
title: 백준 17777 Copy and Paste
layout: post
tags: [cpp]
---
### 문제 개요
> テキストエディタの最も重要な機能の 1 つとして，コピー＆ペースト (複写・貼付) がある．JOI 社は，コ ピー＆ペーストを非常に高速に処理するテキストエディタの開発を開始した．JOI 社に所属する優秀なプ ログラマであるあなたは，核となるコピー＆ペーストの処理の実装の担当となった．JOI 社の命運が懸かっ ているので，何としても正確かつ高速なプログラムを作成したい．  
> 具体的な仕様は次のとおりである．初め，ファイルの内容は文字列 S である．引き続いて，コピー＆ペー ストの操作が N 回行われる．i 回目の操作は，位置 Ai から位置 Bi までの文字列を複写し，複写された文字 列を元の文字列の位置 Ci に挿入貼付する，というものである．ここで，位置 x とは，文字列の先頭から x 個の文字をたどった直後の箇所を表す (位置 0 は文字列の先頭である)．ただし，操作後に文字列の長さが M を超えた場合，長さが M になるまで文字列の右端から順に文字が削除される．N 回の操作後に得られる 文字列を求めたい．  
> 文字列の長さの上限 M，初めの文字列 S，操作の回数 N および N 回のコピー＆ペーストの操作の指示が 与えられたとき，操作後の文字列を出力するプログラムを作成せよ．
> 
> 標準入力から以下の入力を読み込め．
> >1 行目には整数 M が書かれており，文字列の長さの上限を表す．  
> >2 行目には文字列 S が書かれており，初めの文字列を表す．S はアルファベットの小文字からなり， 長さは 1 以上 M 以下である．  
> >3 行目には整数 N が書かれており，操作の回数を表す．  
> >3 + i 行目 (1 ≤ i ≤ N) には整数 Ai, Bi, Ci が空白を区切りとして書かれており，i 回目の操作は位置 Ai から位置 Bi までの文字列を複写し位置 Ci に挿入貼付する，というものであることを表す．i 回目の 操作の直前の文字列の長さを Li とすると，0 ≤ Ai < Bi ≤ Li および 0 ≤ Ci ≤ Li を満たす．
> 
> 準出力に，N 回の操作後の文字列を 1 行で出力せよ．

### 라이브러리 하나 가져오면 끝이라니
처음으로 아무거나 골라잡은 일본어 문제가 이거였는데, 문자열 복사 붙여넣기 구현에 있어 아무리 해도 시간 초과가 나서 몇 달을 헤맸다.  
JOI 공식 솔루션은 레드 블랙 트리를 구현하라고 하던데, 의외로 로프 가져오면 substr 쓰는 간단한 코드로도 풀렸다.
### 코드
```c++
#include <bits/stdc++.h>
#include <ext/rope>

using namespace std;
using namespace __gnu_cxx;

int N, M, A, B, C;
string s;
crope origintext;

int main()
{
	cin.tie(NULL); cout.tie(NULL);
	ios_base::sync_with_stdio(false);

	cin >> M;

	cin >> s;

	cin >> N;
    origintext.append(s.c_str());//로프에 넣어준다
	while (N--) {
		cin >> A >> B >> C;
		origintext = origintext.substr(0, C)+origintext.substr(A, B - A)+origintext.substr(C, M);//조건에 맞게 substr
		origintext = origintext.substr(0, M);//길이를 조정
	}
	cout << origintext;
}
```
### 로프의 성능은 말도 안 된다...
substr 같은 함수로 대충 코드 짜도 말도 안 되는 처리능력을 보여준다...  
다른 문자열 문제도 로프 가져오면 간단히 풀리는 신기한 경험도 했고,  
gnu 확장은 환경에 꼭 구비해두라는 교훈.
