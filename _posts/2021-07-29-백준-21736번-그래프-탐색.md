---
layout: post
title: 백준 21736번 그래프 탐색
tags: [cpp, python]
---

### 문제 개요

> 첫째 줄에는 캠퍼스의 크기를 나타내는 두 정수  N(1 <= N <= 600), M(1 <= M <=600)이 주어진다.  
둘째 줄부터 개의 줄에는 캠퍼스의 정보들이 주어진다.  
O는 빈 공간, X는 벽, I는 도연이, P는 사람이다. I가 한 번만 주어짐이 보장된다.

### 행렬은 싫은데

별로 안 좋아하는 행렬 그래프 문제다.
행렬 배우는 마지막 교육과정이라 행렬을 배우긴 했어도 역시 쓰고 싶진 않은 느낌이다.

### 코드
```c++
#include <iostream>
#include <cstring>

using namespace std;

int ans = 0;//답
int N, M;//입력
int R, C;//주인공 위치 저장
int rm[4] = { -1,1,0,0 };//가능한 행 연산자
int cm[4] = { 0,0,-1,1 };//가능한 열 연산자
bool visit[600][600];//방문 여부(N,M<=600이므로 크기는 600)
string board[600][600];//캠퍼스 정보 저장(N,M<=600이므로 크기는 600)

void GoPath(int r, int c)//경로 탐색 함수
{
	visit[r][c] = true;//입력된 위치에 대해 방문 플래그 on
	if (board[r][c] == "P") {//입력된 위치에 사람이 있다면 답에 카운트
		ans++;
	}
	for (int i = 0; i < 4; i++) {//경로 탐색 반복문
		int rp = r + rm[i];
		int cp = c + cm[i];
    /*반복문을 돌면서 i=1일땐 행으로 -1, 2일땐 행으로 1, 3일땐 열로 -1, 4일땐 열로 1만큼 이동하도록 조정*/
		if (rp >= 0 && cp >= 0 && rp < N && cp < M &&!visit[rp][cp]) {//조정된 좌표가 캠퍼스 범위 내에 존재하고 방문한 적 없을때
			if (board[rp][cp] != "X") {//벽이 아니면
				GoPath(rp, cp);//거기서 경로를 재탐색
			}
		}
	}
}

int main()//메인함수
{
	cin >> N >> M;

	for (int i = 0; i < N; i++)
	{	
		string temp;
		cin >> temp;
		for (int j = 0; j < M; j++) {
			board[i][j] =temp[j];
			if (board[i][j] == "I") {
				R = i; C = j;
			}
		}
	}
/*입력부*/
	GoPath(R, C);//경로 탐색 실행

	if (ans == 0) {
		cout << "TT";
	}
	else {
		cout << ans;
	}
  /*출력*/
}
```

### 해설

일단 입력을 받으면서 동시에 주인공의 행 좌표와 열 좌표를 저장하게 했다.  
그 다음은 경로를 탐색하는 함수를 만들어, 가능한 4방향의 이동에 대해 연산을 하되,  
벽이나 방문한 곳에 대해서는 연산을 하지 않도록 조정해 경로 탐색이 되게 했다.
결국 모든 가능한 지역이 없어지면 경로 재탐색 알고리즘은 끝나고, 결과값을 반환한다.

### 여담

원래는 vector를 이용해 검색된 사람 위치와 주인공 위치만 이용해 경로를 탐색하는 함수를 만들어보려 했으나,

**2차원 벡터는 구조가 더럽게 복잡하다.** 

배열마냥 인덱스 번호를 이용해 추가적인 작업을 하기 좋지도 않고, 선언도 귀찮고, 다른 라이브러리도 써야 하니 그냥 적당히 배열을 썼다.  
재귀함수를 돌려서 시간초과가 뜨지 않을까 걱정했지만, 의외로 그냥 잘 통과됐다.

다음에 할 일 있으면 벡터 쓰는것도 연습을 해보긴 해야겠다.

### 다시 풀어봤다

아무래도 재귀함수 돌리는건 좀 그래서 다시 큐를 이용하는 알고리즘으로 풀어봤다. 

이번엔 파이썬이랑 C++ 둘 다 돌려봤는데, **파이썬은 역시 편하지만 느리다...**

### Python
```python
import sys # 개느린 파이썬 속도 맞춰주려면 sys 라이브러리를 써서 입력을 받아야 함

N, M = map(int, sys.stdin.readline().split())
arr=[sys.stdin.readline() for _ in range(N)]
Visit = [[0]*M for _ in range(N)]
ans=0
Que=[]
move=[(1,0),(-1,0),(0,1),(0,-1)]

for i in range(N):
    for j in range(M):
        if arr[i][j]=='I':
            Que.append(str(i)+' '+str(j))
'''
변수 입력받고 초기화
'''
while len(Que)>0: # 큐가 있으면

     Point=Que.pop() # 큐의 맨 앞 원소를 꺼내온다
     
     r=int(Point.split()[0])
     c=int(Point.split()[1])
     
     for m in move:
        rm, cm = r + m[0], c + m[1]
        if not (0 <= rm < N and 0 <= cm < M): continue
        if Visit[rm][cm] or arr[rm][cm] == 'X': continue
	'''
	조건이 삑나는 순간 빠른 continur로 시간을 단축한다
	'''
        Que.append(str(rm)+' '+str(cm)) # 큐에 새 좌표 입력
        Visit[rm][cm]=1 # 방문여부에 체크
        if arr[rm][cm] == 'P':
             ans+=1 # 만난거 카운트
if ans==0:
    print('TT')
else:
    print(ans)
```

### C++
```c++
#include "pch.h"
#include <iostream>
#include <queue>

using namespace std;

int ans = 0;
int N, M;
int R, C;
int rm[4] = { -1,1,0,0 };
int cm[4] = { 0,0,-1,1 };
bool visit[600][600] = { false };
string board[600][600];
queue<pair<int, int>> q; // 큐 선언

int main()
{
	cin >> N >> M;

	for (int i = 0; i < N; i++)
	{
		string temp;
		cin >> temp;
		for (int j = 0; j < M; j++) {
			board[i][j] = temp[j];
			if (board[i][j] == "I") {
				q.push(make_pair(i, j));			
			}
		}
	}
	/* 입력받으면서 동시에 큐에 넣음 */
	while (!q.empty())
	{
		for (int k = 0; k < 4; k++) {
			int Nr = q.front().first + rm[k];
			int Nc = q.front().second + cm[k];
			if (Nr < 0 || Nc < 0 || Nr >= N || Nc >= M) {
				continue;
			}
			if (board[Nr][Nc] == "X" || visit[Nr][Nc] == true) {
				continue;
			}
			if (board[Nr][Nc] == "P") {
				ans++;
			}
			q.push(make_pair(Nr, Nc));
			visit[Nr][Nc] = true;
		}
		q.pop();
	}
	/*파이썬으로 한거랑 기본 구조는 같은데 pop가 여기선 앞 원소 대응하며 삭제가 아니라 그냥 삭제라 따로 해줬음*/
	if (ans == 0) {
		cout << "TT";
	}
	else {
		cout << ans;
	}
}
```

### 자료형이 생각보다 많더라고

이걸 하면서 해멘 이유 대부분은 큐나 페어 자료형에 대해 모른채 배열이나 벡터 선에서 다 해보려고 해서다.

좋은 자료형들 두고 굳이 배열 쓰면서 컴파일 에러를 무수하게 냈다.

다음부턴 자료형을 알맞게 쓰자.
