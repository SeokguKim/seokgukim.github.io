---
layout: post
title: 백준 21736번 그래프 탐색
tags: [cpp]
---

### 문제 개요

> 첫째 줄에는 캠퍼스의 크기를 나타내는 두 정수  N(1 <= N <= 600), M(1 <= M <=600)이 주어진다.  
둘째 줄부터 개의 줄에는 캠퍼스의 정보들이 주어진다.  
O는 빈 공간, X는 벽, I는 도연이, P는 사람이다. I가 한 번만 주어짐이 보장된다.

### 행렬은 싫은데

별로 안 좋아하는 행렬 그래프 문제다.
행렬 배우는 마지막 교육과정이라 행렬을 배우긴 했어도 역시 쓰고 싶진 않은 느낌이다.

### 코드
```c++
#include <iostream>
#include <cstring>

using namespace std;

int ans = 0;//답
int N, M;//입력
int R, C;//주인공 위치 저장
int rm[4] = { -1,1,0,0 };//가능한 행 연산자
int cm[4] = { 0,0,-1,1 };//가능한 열 연산자
bool visit[600][600];//방문 여부(N,M<=600이므로 크기는 600)
string board[600][600];//캠퍼스 정보 저장(N,M<=600이므로 크기는 600)

void GoPath(int r, int c)//경로 탐색 함수
{
	visit[r][c] = true;//입력된 위치에 대해 방문 플래그 on
	if (board[r][c] == "P") {//입력된 위치에 사람이 있다면 답에 카운트
		ans++;
	}
	for (int i = 0; i < 4; i++) {//경로 탐색 반복문
		int rp = r + rm[i];
		int cp = c + cm[i];
    /*반복문을 돌면서 i=1일땐 행으로 -1, 2일땐 행으로 1, 3일땐 열로 -1, 4일땐 열로 1만큼 이동하도록 조정*/
		if (rp >= 0 && cp >= 0 && rp < N && cp < M &&!visit[rp][cp]) {//조정된 좌표가 캠퍼스 범위 내에 존재하고 방문한 적 없을때
			if (board[rp][cp] != "X") {//벽이 아니면
				GoPath(rp, cp);//거기서 경로를 재탐색
			}
		}
	}
}

int main()//메인함수
{
	cin >> N >> M;

	for (int i = 0; i < N; i++)
	{	
		string temp;
		cin >> temp;
		for (int j = 0; j < M; j++) {
			board[i][j] =temp[j];
			if (board[i][j] == "I") {
				R = i; C = j;
			}
		}
	}
/*입력부*/
	GoPath(R, C);//경로 탐색 실행

	if (ans == 0) {
		cout << "TT";
	}
	else {
		cout << ans;
	}
  /*출력*/
}
```

### 해설

일단 입력을 받으면서 동시에 주인공의 행 좌표와 열 좌표를 저장하게 했다.  
그 다음은 경로를 탐색하는 함수를 만들어, 가능한 4방향의 이동에 대해 연산을 하되,  
벽이나 방문한 곳에 대해서는 연산을 하지 않도록 조정해 경로 탐색이 되게 했다.
결국 모든 가능한 지역이 없어지면 경로 재탐색 알고리즘은 끝나고, 결과값을 반환한다.

### 여담

원래는 vector를 이용해 검색된 사람 위치와 주인공 위치만 이용해 경로를 탐색하는 함수를 만들어보려 했으나,

**2차원 벡터는 구조가 더럽게 복잡하다.** 

배열마냥 인덱스 번호를 이용해 추가적인 작업을 하기 좋지도 않고, 선언도 귀찮고, 다른 라이브러리도 써야 하니 그냥 적당히 배열을 썼다.  
재귀함수를 돌려서 시간초과가 뜨지 않을까 걱정했지만, 의외로 그냥 잘 통과됐다.

다음에 할 일 있으면 벡터 쓰는것도 연습을 해보긴 해야겠다.

