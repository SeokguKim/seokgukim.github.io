---
title: 백준 2098번 외판원 순회
layout: post
tags: [cpp]
---
### 문제 개요
> 외판원 순회 문제는 영어로 Traveling Salesman problem (TSP) 라고 불리는 문제로 computer science 분야에서 가장 중요하게 취급되는 문제 중 하나이다. 여러 가지 변종 문제가 있으나, 여기서는 가장 일반적인 형태의 문제를 살펴보자.  
> 1번부터 N번까지 번호가 매겨져 있는 도시들이 있고, 도시들 사이에는 길이 있다. (길이 없을 수도 있다) 이제 한 외판원이 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 단, 한 번 갔던 도시로는 다시 갈 수 없다. (맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외) 이런 여행 경로는 여러 가지가 있을 수 있는데, 가장 적은 비용을 들이는 여행 계획을 세우고자 한다.  
> 각 도시간에 이동하는데 드는 비용은 행렬 W[i][j]형태로 주어진다. W[i][j]는 도시 i에서 도시 j로 가기 위한 비용을 나타낸다. 비용은 대칭적이지 않다. 즉, W[i][j] 는 W[j][i]와 다를 수 있다. 모든 도시간의 비용은 양의 정수이다. W[i][i]는 항상 0이다. 경우에 따라서 도시 i에서 도시 j로 갈 수 없는 경우도 있으며 이럴 경우 W[i][j]=0이라고 하자.  
> N과 비용 행렬이 주어졌을 때, 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하시오.
> 
> 첫째 줄에 도시의 수 N이 주어진다. (2 ≤ N ≤ 16) 다음 N개의 줄에는 비용 행렬이 주어진다. 각 행렬의 성분은 1,000,000 이하의 양의 정수이며, 갈 수 없는 경우는 0이 주어진다. W[i][j]는 도시 i에서 j로 가기 위한 비용을 나타낸다.  
> 항상 순회할 수 있는 경우만 입력으로 주어진다.
> 
> 첫째 줄에 외판원의 순회에 필요한 최소 비용을 출력한다.

### 웰노운
학교에서 경영과학 할 때도 한번은 접했던 종류의 문제다.  
당시엔 엑셀로 대충 했지만 이번엔 본격적으로 코딩으로 해보는 셈.  
수업 들을 당시에 CS지식을 가지고 있었다면 좋았을걸 하고 생각하게 되는 시간이었다.  

기본적으로 DP로 풀어야 하는 문제인데, 각 정점의 상태를 독립된 상태로 관리하면 접근하기 힘든 정도로 고차원이 되어버린다.  
비트로 방문 상태를 관리하여 비트마스킹을 이용하면 최대 16개의 정점에 대한 방문 여부를 관리하게 되는데,  
이 때 비트마스킹에 사용되는 방문 배열 크기는 2^16 = 65536이 된다. 
### 코드
```c++
#include <iostream>
#include <memory.h>
#define INF 1e9//적당히 큰 수를 잡아서 무한값으로 쓴다

using namespace std;
typedef long long ll;
int N;
int cost[16][16];
ll dp[65536][16];//각 정점에 대한 방문 여부로, 2^N * N개만큼 필요한데, N이 최대 16이므로 2^16, 16

ll tsp(unsigned int visit, int cur) {//visit에 해당하는 상태와 cur 번호 정점에 배해
	visit = visit | 1 << cur;//상태에 현재 정점의 방문 여부를 추가해준다
	if (dp[visit][cur] != -1) return dp[visit][cur];//여기서 dp값이 초기값이 아니면 미리 계산한 dp값을 리턴
	if (visit == (1 << N) - 1) {//모든 정점에 대해 방문이 완료된 상태라면 N자리의 비트에 대해 1을 가지는 visit가 되는데, 이는 (1 << N) - 1로 표현이 가능하다
		if (!cost[cur][0]) return INF;//시작 정점으로 가는 길이 없으면 무한을 리턴
		else return cost[cur][0];//시작 정점으로 갈 수 있다면, 해당 경로의 비용을 리턴. 같은 경로 상에서는 다른 어느 정점에서 출발하든 사이클을 돌아 같은 경우가 되므로, 시작 정점 하나에 대해서만 해줘도 된다. 
	}
	dp[visit][cur] = INF;//dp값이 계산 안 되어있고 완주하지 않았다면 일단 무한으로 세팅
	for (int i = 0; i < N; i++) {//다른 모든 정점에 대해
		if (visit & 1 << i || !cost[cur][i]) continue;//현재 상태에서 방문했거나 경로가 존재하지 않는 정점은 건너뛰고
		dp[visit][cur] = min(dp[visit][cur], cost[cur][i] + tsp(visit, i));//dp값은 이 시점에서 선택된 경로의 비용 + 도착지점으로부터의 재귀함수와 비교해 최솟값을 취한다
	}
	return dp[visit][cur];//마지막으로 최솟값을 리턴
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> N;
	memset(dp, -1, sizeof(dp));//dp 초기값 -1로 세팅
	for (int i = 0; i < N; i++) for (int j = 0; j < N; j++) cin >> cost[i][j];
	cout << tsp(0, 0);
}
```
### 여담
적당히 큰 수를 무한으로 잡아줘야 더해서 리턴하는 재귀 과정에서 오버플로우가 나지 않는다. 대충 1e9 정도로.
### 플래 달성
1년 좀 안 되는 시간동안 열심히 풀어서, **드디어 솔브닥 플래티넘을 달았다. 와!**

![image](https://user-images.githubusercontent.com/43718966/168500604-d72ed462-7a66-471f-8d0d-ae5413222c0b.png)

골드 2나 1쯤 될 때부터 플래티넘이 가시권에 들어오니 기여가 해금된다는 생각에 설레어서 하루에 4~5문제 정도 신나게 달렸던 것 같다.  
스터디도 있고 앞으로 더 열심히 해야지.
