---
title: 백준 21968번 정수론
layout: post
tags: [cpp]
---
### 문제 개요

> 첫 번째 줄에 여러분들이 찾아야 하는 선린의 터의 개수 T가 주어진다.
두 번째 줄부터 T개의 줄에 여러분들이 찾아야 하는 선린의 터에 대한 정보 N이 주어진다.
여러분들이 찾아야 하는 선린의 터의 번호를 한 줄에 하나씩 차례대로 출력한다.
1<=T<=1,000,
1<=N<=123,456,789,123

### 정수의 성질을 활용하자

일단 문제 알고리즘의 분류는 정수론. 그리고 거듭제곱을 1번 이하로만 쓴 합을 이용하는 문제다.

조금 생각하니까 의외로 금방 풀렸다.

### 코드

```c++
#include <iostream>

using namespace std;

unsigned long long my_pow(unsigned long long base, int exp) { unsigned long long res = 1; while (exp) { if (exp & 1) res *= base; exp >>= 1; base *= base; } return res; }
/* pow 대체 함수 */
int main()
{   
    int N;
    cin >> N;
    
    long long board[1000];
    
    for (int i = 0; i < N; i++)
        cin >> board[i];
    /* 입력 */
    for (int j = 0; j < N; j++){
        long long answer = 0;
        int achk=0;
        int arr[1000];
        long long num = board[j];
        while(num != 0)
        {
            arr[achk] = num % 2;
            achk++;
            num /= 2;
            /* 배열에 2진수 저장 */
        }
        for (int k = 0; k < achk; k++){
            answer += my_pow(3,k)*arr[k];
            /* 3진법화 */
        }
        cout << answer << '\n';
        /* 출력 */
    }
}
```

### 해설

N^n > N^0+N^1+...+N^(n-1) 이라는 사실에 주목해서 보면 터 순서는 3^0, 3^1, 3^0+3^1, 3^2... 이런 식으로 가게 되는데,

이때 3^n승이 총합에 들어가는지의 여부를 0과 1로 나타내면 2진법 수가 되는 것이다.

따라서 고놈의 터 번호는 일단 2진법으로 N을 나타낸 후, 그걸 3진법으로 변환하면 된다.

그래서 이중 반복문을 이용해 배열에 입력받은 각 숫자들에 대해 2진법 변환을 한 후, 3진법화해서 출력하는 알고리즘을 작성했다.

### 여담

진법 변환의 알고리즘이 많아도 너무 많다는게 귀찮았다.

2진법 변환에 비트 연산을 쓰는 경우도 있고 배열을 사용하는 경우도 있지만, 이 경우엔 배열에 한번 저장할 필요가 있었으므로 저렇게 나머지 연산으로 배열에 할당하는 코드가 되었다.

또한 answer를 만드는 반복문에 동적 범위를 할당하기 위해 지역변수 achk를 썼다.

3진법으로 변환하는 과정에서 처음엔 math.h를 써서 pow를 가져오려 했지만, 문제는 이게 double 형으로 처리되기에, 큰 수의 연산에서는 값이 차이가 나서 틀렸다.

알고리즘 다 짜놓은걸 바꾸기도 귀찮고 해서 적당히 누군가 만들어둔 정수(long long) 기반의 거듭제곱 함수를 갖다박으니 정답으로 처리되었다.

역시 내가 하려는 기능은 대부분 누군가가 만들어놨다. 잘 찾는게 장땡이지 뭐.
