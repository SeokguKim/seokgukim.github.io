---
title: 백준 1799번 비숍
layout: post
tags: [cpp]
---
### 문제 개요
> 서양 장기인 체스에는 대각선 방향으로 움직일 수 있는 비숍(bishop)이 있다. < 그림 1 >과 같은 정사각형 체스판 위에 B라고 표시된 곳에 비숍이 있을 때 비숍은 대각선 방향으로 움직여 O로 표시된 칸에 있는 다른 말을 잡을 수 있다.  
> ![image](https://user-images.githubusercontent.com/43718966/167973467-e38935f0-673d-4f06-a329-da074a1d612f.png)
> 
> < 그림 1 >
> 
> 그런데 체스판 위에는 비숍이 놓일 수 없는 곳이 있다. < 그림 2 >에서 체스판에 색칠된 부분은 비숍이 놓일 수 없다고 하자. 이와 같은 체스판에 서로가 서로를 잡을 수 없도록 하면서 비숍을 놓는다면 < 그림 3 >과 같이 최대 7개의 비숍을 놓을 수 있다.  색칠된 부분에는 비숍이 놓일 수 없지만 지나갈 수는 있다.  
> 
> ![image](https://user-images.githubusercontent.com/43718966/167973486-7d33df25-2cf3-481e-9f85-8c86be6f936b.png)
>
> < 그림 2 >
> 
> ![image](https://user-images.githubusercontent.com/43718966/167973564-ba0b2095-dc48-4c59-b803-bd6efa4f8bfd.png)
>
> < 그림 3 >
>  
> 정사각형 체스판의 한 변에 놓인 칸의 개수를 체스판의 크기라고 한다. 체스판의 크기와 체스판 각 칸에 비숍을 놓을 수 있는지 없는지에 대한 정보가 주어질 때, 서로가 서로를 잡을 수 없는 위치에 놓을 수 있는 비숍의 최대 개수를 구하는 프로그램을 작성하시오.  
> 
> 첫째 줄에 체스판의 크기가 주어진다. 체스판의 크기는 10이하의 자연수이다. 둘째 줄부터 아래의 예와 같이 체스판의 각 칸에 비숍을 놓을 수 있는지 없는지에 대한 정보가 체스판 한 줄 단위로 한 줄씩 주어진다. 비숍을 놓을 수 있는 곳에는 1, 비숍을 놓을 수 없는 곳에는 0이 빈칸을 사이에 두고 주어진다.
> 
> 첫째 줄에 주어진 체스판 위에 놓을 수 있는 비숍의 최대 개수를 출력한다.

### 다른 색 칸의 비숍끼리는 절대로 안 만난다
단순히 전체 체스판만 놓고 생각하자면 모든 칸에 비숍이 놓아지는 최악의 경우 O(2^(10^2))가 되므로, 시간초과가 난다.  
흑백으로 칸을 나누어 생각해보면, 검은색 칸 비숍과 흰색 칸 비숍은 이동경로가 절대 겹치지 않는다.  
따라서 흑백 칸에 대해 구한 것을 단순히 합치면 시간복잡도가 극적으로 줄어든다.
### 코드 
```c++
#include <iostream>
#include <vector>
using namespace std;
typedef pair<int, int> pii;
int N, ip, cnt[2], ans[2];//cnt는 현재 카운트, ans는 최대 개수
vector<pii> bshop[2];//흑백 칸에 대해 모든 가능한 칸을 저장
bool poss[19], negs[19];//점유중인 대각선에 대한 정보

void solve(int n, int bw) {//인덱스, 색 정보를 패러미터로 사용
    if (bshop[bw].size() - n + 1 + cnt[bw] <= ans[bw]) return;//최대값보다 가능성이 작다면 기각
    if (n == bshop[bw].size()) {//인덱스가 해당 색의 크기를 넘어서고(끝까지 탐색) 위에서 안 걸리면(최대)
        ans[bw] = cnt[bw];//현재 카운트를 최댓값으로 설정
        return;//종료
    };
    int x = bshop[bw][n].first, y = bshop[bw][n].second;
    if (!poss[x + y] && !negs[N - 1 + x - y]) {//양/음의 대각선에 대해 걸리지 않으면
        poss[x + y] = negs[N - 1 + x - y] = 1;//해당 좌표를 기준으로 양/음의 대각선을 체크
        cnt[bw]++;//선택하므로 카운트 +1
        solve(n + 1, bw);//선택한 상황으로부터 재귀
        cnt[bw]--;//선택 해제하므로 카운트 -1
        poss[x + y] = negs[N - 1 + x - y] = 0;//좌표 기준 양/음 대각선 체크 해제
    }
    solve(n + 1, bw);//백트래킹
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin >> N;
    for (int i = 0; i < N; i++) for (int j = 0; j < N; j++) {
        cin >> ip;
        if (ip) bshop[(i + j) & 1].push_back({ i,j });//입력받은 좌표에 따라 흑/백 비숍 벡터에 삽입
    }
    solve(0, 0);//색0에 대해 최댓값 구하기
    solve(0, 1);//색1에 대해 최댓값 구하기
    cout << ans[0] + ans[1];//구한 최댓값을 합해 출력
}
```
### 여담
빠르게 푼다고 가능한 칸만 추려 푸는 식으로 생각했지만, 근본적으로 흑/백을 나눈다는 발상까지는 바로 도달하지 못했다.  
괜히 벡터랑 큐만 건들다 시간만 날렸던 문제.
