---
title: 백준 25242 가희와 지하철
layout: post
tags: [cpp]
---
### 문제 개요
> **문제**  
> 가희는 노선이 N개 있는 서울 지하철의 매력에 푹 빠졌습니다. 그래서 Q일 동안 출발지에서 목적지까지 서울 지하철만 타고 가려고 합니다.  
> 그런데, 가희는 출발지에서 목적지까지 가장 시간이 적게 걸리는 방법으로 이동하려고 합니다. 가희를 도와주세요.  
> 단, 한 역에서 인접 역까지 소요 시간은 2분으로 같고, 다른 노선으로 환승하는 시간은 무시합니다.

> **입력**  
> 첫 번째 줄에 N과 Q가 공백으로 구분되어 주어집니다.  
> 두 번째 줄부터 N개의 줄에 노선의 역 개수 s와 노선에 있는 역 이름들이 주어집니다.  
> 이때, 역 이름은 해당 노선의 1번 역부터 s번 역까지 공백으로 구분되어 주어지며, 각 역은 아래 조건에 맞습니다.
> 
> > 하행의 시발역은 1번 역이고, 종착역은 s번 역이며, 상행의 시발역은 s번 역이고, 종착역은 1번 역입니다.  
> > 하행에서 x번 역의 다음 역은 x+1번 역이며, 종착역에 도착한 후에는 운행을 종료합니다.  
> > 상행에서 x+1번 역의 다음 역은 x번 역이며, 종착역에 도착한 후에는 운행을 종료합니다.  
> > 예를 들어 3 ab cd ef로 노선이 주어지는 경우, 해당 노선의 상행, 하행은 아래와 같이 운행합니다.
> 
> 하행은 1번역인 ab역에서 운행을 시작해서, cd역, ef역 순으로 멈춥니다. ef역에 도착한 후에는 운행을 종료합니다.  
> 상행은 3번역인 ef역에서 운행을 시작해서, cd역, ab역 순으로 멈춥니다. ab역에 도착한 후에는 운행을 종료합니다.  
> 다음 Q개의 줄에는 출발지와 목적지가 공백으로 구분되어 주어집니다.

> **출력**  
> Q개의 줄에 답을 출력해 주세요. 만약, 갈 수 없다면 -1을 출력해 주세요.

> **제한**  
> 1 ≤ N ≤ 10^5  
> 1 ≤ Q ≤ 10^5  
> 각 노선에는 최소 둘 이상의 역이 있으며, 같은 이름의 역이 중복해서 나오지 않습니다.  
> 환승역은 20개 이하입니다.  
> 루프선, 순환선, 지선은 없으며, 다른 지역에 있는 동명의 역 (ex. 양평)도 없습니다.  
> 역명은 대소문자로만 이루어져 있으며, 길이는 8 이하입니다.  
> 1 ≤ N개의 노선에 있는 역의 수의 총합 ≤ 2 × 105

### 해싱만 해선 안 끝난다
기본적으로 들어오는 역 명 문자열에 대해선 해시 함수를 써서 해싱을 해줘야 하는건 딱 봐도 보인다.  
역 간 거리는 주어진 역이 직통이거나, 환승역을 거치는 두 가지 케이스로 분류할 수 있다.  
환승역이 20개 이하이므로, 미리 다익스트라를 돌려서 각 환승역 사이의 거리를 계산해 두면 편리하다.
### 코드
```c++
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;
typedef long long ll;

int N, M, cc;//노선 수, 쿼리 수, 노선의 역 수를 받을 변수
ll base = 31, mod = 1e15 + 31;//해싱에 쓸 값들
string s, p;
unordered_map<ll, unordered_map<int, int>> mm;//역 정보 저장 map
vector<vector<pair<int, ll>>> terminal;//노선별 환승역 정보 저장 벡터
vector<ll> ts;//환승역 리스트 벡터
unordered_map<ll, unordered_map<ll, ll>> d;//환승역간 거리 저장 map

ll rabin_hash(string s) {//해시함수. umap을 쓰자니 숫자형으로 넣어야 성능이 좋아지더라
    ll ans = 0;
    for (char ch : s) {
        ans = (ans * base + ch) % mod;//각 문자에 대해 처리
    }
    return ans;
}

void betweentrans() {//환승역 간 거리 계산 함수
    for (ll i : ts) {//모든 환승역에 대해
        priority_queue<pair<ll, ll>> q;//다익스트라 할 것이므로 우선순위 큐
        q.push({ 0, i });//시작
        d[i][i] = 0;//자신과의 거리는 0
        while (!q.empty()) {//다익스트라 진행
            ll cost = -q.top().first, cur = q.top().second;//cost가 총 시간, cur는 현재 역
            q.pop();//큐 날림
            if (d[i].find(cur) != d[i].end() && d[i][cur] < cost) continue;//현재 역까지의 거리가 최저가 될 가능성이 없다면 날림
            for (auto ii : mm[cur]) for (auto jj : terminal[ii.first]) {//현재 역에서 갈 수 있는 환승역들에 대해
                if (jj.second == cur || jj.second == i) continue;//자기 자신이나 시작점이면 스킵
                ll toterminal = cost + ((ll)abs(ii.second - jj.first) << 1);//현재까지의 시간 + 해당 노선에서의 인덱스 차 * 2 가 총 비용
                if (d[i].find(jj.second) == d[i].end() || d[i][jj.second] > toterminal) {//총 비용이 최솟값이면
                    q.push({ -toterminal,jj.second });//큐에 넣고
                    d[i][jj.second] = toterminal;//최솟값 갱신
                }
            }
        }
    }
}

ll minpath(ll s, ll p) {//최단거리 계산
    if (s == p) return 0;//똑같은건 바로 0
    ll minn = 5000000;//최대 20만개의 역이므로, 초기값을 적당히 설정
    unordered_map <ll, unordered_map<ll, ll>> dd;//각 끝점으로부터 환승역까지의 거리 저장

    for (auto ii : mm[s]) {//시작역에 대해
        if (mm[p].find(ii.first) != mm[p].end()) {//끝역과 같은 노선에 있다면
            ll cost = ((ll)abs(ii.second - mm[p][ii.first]) << 1);//비용은 해당 노선의 인덱스 차 * 2
            minn = min(minn, cost);//최솟값 처리
        }
        for (auto jj : terminal[ii.first]) {//해당 역의 노선상의 환승역에 대해
            ll toterminal = ((ll)abs(ii.second - jj.first) << 1);//해당 환승역까지의 거리
            if(dd[s].find(jj.second) == dd[s].end() || dd[s][jj.second] > toterminal) dd[s][jj.second] = toterminal;//최단거리라면 설정해줌
        }
    }
    for (auto ii : mm[p]) for (auto jj : terminal[ii.first]) {//도착역이 있는 노선상의 환승역에 대해
        ll toterminal = ((ll)abs(ii.second - jj.first) << 1);//해당 환승역까지의 거리
        if (dd[p].find(jj.second) == dd[p].end() || dd[p][jj.second] > toterminal) dd[p][jj.second] = toterminal;//최단거리라면 설정해줌
    }
    for (auto i : dd[s]) for (auto j : dd[p]) {//구해놓은 환승역까지의 조합으로
        if (d[i.first].find(j.first) != d[i.first].end()) minn = min(minn, i.second + j.second + d[i.first][j.first]);//두 환승역 사이의 경로가 존재한다면 계산해줌
    }

    if (minn == 5000000) return -1;//이래도 최솟값이 초기값이면 경로가 없으므로 -1 반환
    return minn;//아니면 계산된 최솟값 반환
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);

    cin >> N >> M;
    terminal.resize(N);//일단 환승역 벡터는 노선 크기에 맞춤
    for (int i = 0; i < N; i++) {
        cin >> cc;
        for (int j = 0; j < cc; j++) {
            cin >> s;//노선의 역 입력 받고
            ll cur = rabin_hash(s);//해시 돌림
            if (mm[cur].size()) {//이미 방문한적 있다면(환승역)
                if (mm[cur].size() == 1) terminal[(*mm[cur].begin()).first].push_back({ (*mm[cur].begin()).second, cur }), ts.push_back(cur);//정확히 사이즈가 1인 경우엔 이미 있는 환승역 정보 입력
                terminal[i].push_back({ j,cur });//환승역 정보 입력
            }
            mm[cur][i] = j;//역 정보 갱신
        }
    }
    betweentrans();//환승역 간 경로 계산
    while (M--) {//쿼리 돌림
        cin >> s >> p;
        cout << minpath(rabin_hash(s), rabin_hash(p)) << "\n";
    }
}
```
### 할게 은근히 많다
처음에 딱 봤을때 그냥 너비 우선 탐색만 해도 될 줄 알았지만, 시간이나 메모리 제한에 맞게 하려고 해시도 바꿔보고 전처리도 해보고 여러모로 고생했다.  
특히 전처리 함수를 처음 만들때 map 컨테이너에서 참조만 하려 해도 버킷이 생겨버려서 쓰레기 값이 들어갈 수 있단걸 몰라서 디버깅 하느라 한참을 헤맸다.  
다음부턴 find 잘 써야지...
