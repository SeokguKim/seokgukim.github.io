---
title: 백준 11779번 최소비용 구하기 2
layout: post
tags: [cpp]
---
### 문제 개요
> n(1 ≤ n ≤ 1,000)개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 m(1 ≤ m ≤ 100,000)개의 버스가 있다. 우리는 A번째 도시에서 B번째 도시까지 가는데 드는 버스 비용을 최소화 시키려고 한다. 그러면 A번째 도시에서 B번째 도시 까지 가는데 드는 최소비용과 경로를 출력하여라. 항상 시작점에서 도착점으로의 경로가 존재한다.
> 
> 첫째 줄에 도시의 개수 n(1≤n≤1,000)이 주어지고 둘째 줄에는 버스의 개수 m(1≤m≤100,000)이 주어진다. 그리고 셋째 줄부터 m+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 그리고 그 다음에는 도착지의 도시 번호가 주어지고 또 그 버스 비용이 주어진다. 버스 비용은 0보다 크거나 같고, 100,000보다 작은 정수이다.  
> 그리고 m+3째 줄에는 우리가 구하고자 하는 구간 출발점의 도시번호와 도착점의 도시번호가 주어진다.
> 
> 첫째 줄에 출발 도시에서 도착 도시까지 가는데 드는 최소 비용을 출력한다.  
> 둘째 줄에는 그러한 최소 비용을 갖는 경로에 포함되어있는 도시의 개수를 출력한다. 출발 도시와 도착 도시도 포함한다.  
> 셋째 줄에는 최소 비용을 갖는 경로를 방문하는 도시 순서대로 출력한다.

### 흔한 다익스트라
양의 비용만 가지는 단방향 간선들만 주어지는 전형적인 다익스트라 문제다.  
다만 메모리 제한이 좀 빡세므로 메모리 이용을 잘 하자.
### 코드
```c++
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;
#define INF 100000000
typedef long long ll;
typedef pair<int,int> pii;
typedef struct dis {//거리 구조체
    ll cost;
    int cur;
    dis(ll a, int b) {
        cost = a;
        cur = b;
    }
    bool operator< (const dis& aa)const {//우선순위 큐에 넣을때 비용 작은 순으로 정렬되게 함
        return cost > aa.cost;
    }
}dis;
int N, M, a, b, c;
vector<pair<ll,int>> dist;//거리를 계산할 벡터
vector<vector<pii>> vertex;//간선을 저장할 벡터
priority_queue<dis> pq;//계산용 우선순위 큐

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin >> N >> M;
    vertex.assign(N + 1, vector<pii>());//N번 인덱스까지 간선 벡터를 확장
    dist.assign(N + 1, pair<ll, int>(INF, 0));//N번 인덱스까지 거리 벡터를 확장
    while(M--) {
        cin >> a >> b >> c;
        vertex[a].push_back({ b,c });//받은 입력을 간선 벡터에 넣어줌
    }
    cin >> a >> b;
    pq.push({ 0,a });//초기에 0의 비용과 시작점을 넣어줌
    while (!pq.empty()) {//큐 끝까지
        ll cost = pq.top().cost;//현재까지의 비용
        int cur = pq.top().cur;//현재 지점
        pq.pop();//큐 날림
        if (dist[cur].first < cost) continue;//계산된 최저 비용보다 현재 비용이 높으면 날림
        for (int i = 0; i < vertex[cur].size(); i++) {//아닌 경우 간선을 다 탐색
            int nex = vertex[cur][i].first, nexc = cost + vertex[cur][i].second;//간선을 선택했을 때의 비용과 다음 목적지
            if (nexc < dist[nex].first){//계산된 비용이 해당 지점의 최저 비용보다 적을땐
                dist[nex].first = nexc; 
                dist[nex].second = cur;
                //거리 정보를 업데이트 후
                pq.push({ nexc,nex});//큐에 넣어줌
            }
        }
    }
    vector<int>v = { b };//최종 목적지로부터 경로를 찾아갈 벡터
    while (v.back() != a) v.push_back(dist[v.back()].second);//출발지에 도달할 때 까지 이전 노드를 찾아가며 벡터에 추가
    cout << dist[b].first << "\n";//최종 거리 출력
    cout << v.size() << "\n";//경로의 도시 수 출력
    for (auto i = v.rbegin(); i != v.rend(); i++) cout << *i << " ";//역순으로 벡터에 경로를 쌓았으므로 반대로 출력
}
```
### 제약 때문에 귀찮다
다익스트라인건 딱 봐도 보이는데, 메모리를 빡세게 줘서 고정 크기 배열로 하면 MLE가 되어버린다.  
벡터를 써서 크기를 잘 조정하자.
