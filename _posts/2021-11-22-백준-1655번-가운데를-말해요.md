---
title: 백준 1655번 가운데를 말해요
layout: post
tags: [cpp]
---
### 문제 개요
> 백준이는 동생에게 "가운데를 말해요" 게임을 가르쳐주고 있다. 백준이가 정수를 하나씩 외칠때마다 동생은 지금까지 백준이가 말한 수 중에서 중간값을 말해야 한다. 만약, 그동안 백준이가 외친 수의 개수가 짝수개라면 중간에 있는 두 수 중에서 작은 수를 말해야 한다.
> 예를 들어 백준이가 동생에게 1, 5, 2, 10, -99, 7, 5를 순서대로 외쳤다고 하면, 동생은 1, 1, 2, 2, 2, 2, 5를 차례대로 말해야 한다. 백준이가 외치는 수가 주어졌을 때, 동생이 말해야 하는 수를 구하는 프로그램을 작성하시오.
> 
> 첫째 줄에는 백준이가 외치는 정수의 개수 N이 주어진다. N은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수이다. 그 다음 N줄에 걸쳐서 백준이가 외치는 정수가 차례대로 주어진다. 정수는 -10,000보다 크거나 같고, 10,000보다 작거나 같다.
> 
> 한 줄에 하나씩 N줄에 걸쳐 백준이의 동생이 말해야 하는 수를 순서대로 출력한다.

### 우선순위 큐로 돌린다
문제 제한시간과 용량이 말도 안 되게 짧다.
일반적으로 벡터를 정렬하고 n/2번 인덱스의 값을 찾는 방식으론 구현하면 망한다는 뜻.
내림차순의 우선순위 큐와 오름차순의 우선순위 큐 하나씩을 이용해 top에만 접근하게 해서 빠르게 풀어보자.
### 코드
```c++
#include <iostream>
#include <queue>

using namespace std;

int N;//숫자수 N

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    cin >> N;//N입력
    priority_queue<int> small;//작은 수들을 저장할 내림차순 우선순위큐
    priority_queue<int, vector<int>, greater<int> > big;//큰 수들을 저장할 오름차순의 우선순위큐
    for (int i = 1; i <= N; i++) {
        int a;//입력받을 수
        cin >> a;//입력
        if (i==1) small.push(a);//첫 케이스는 무조건 작은 수에 넣는다
        else {//그게 아니라면
            if (a < small.top()) small.push(a);//a가 현재 작은쪽 제일 큰 수(현재 중앙값)보다 작다면 작은 쪽에 삽입해주고
            else big.push(a);//아니면 큰 쪽에 삽입한다
            
            if (small.size() < big.size()) {//작은쪽 크기보다 큰 쪽 크기가 커지는 경우엔 이동이 필요하다.
                small.push(big.top());//큰 쪽에서 가장 작은 수를 작은 쪽으로 옮겨주고
                big.pop();//그 수를 지운다
            }
            else if (small.size() > big.size() + 1) {//작은쪽 크기가 큰 쪽보다 2 이상 커져도 이동이 필요하다.
                big.push(small.top());//작은 쪽에서 가장 큰 수를 큰 쪽으로 옮겨주고
                small.pop();//그 수를 지운다
            }
        }
        cout << small.top() << "\n";//일련의 과정을 거치면 작은 쪽의 가장 큰 수가 중앙값에 해당한다
    }
}
```
### 해설
입력이 하나하나 주어지고, 실시간으로 중앙값을 찾아야 하는 상황이다.  
일단 내림차순으로 정렬되는 작은 쪽과, 오름차순으로 정렬되는 큰 쪽 우선순위 큐를 만든다.  
그 다음, 작은 쪽의 top 값을 기준으로, 삽입할 때 해당 값을 기준으로 크면 큰 쪽에, 아니면 작은 쪽에 삽입한 뒤 두 우선순위 큐의 크기를 판단해 조정해주면 작은 쪽의 top값을 중앙값으로 놓을 수 있다.  
두 우선순위 큐로 중앙값을 구하는 방법은 [**여기**](https://o-tantk.github.io/posts/finding-median/)를 참고했다.
### 여담
처음 발상은 우선순위 큐의 비교 함수를 수정해 윗부분에 항상 중앙값이 오게 하는 거였지만, 아무리 찾아보고 생각해봐도 안돼서 포기.  
2개의 우선순위 큐로 하는 위 방법을 찾아 적용했다.
