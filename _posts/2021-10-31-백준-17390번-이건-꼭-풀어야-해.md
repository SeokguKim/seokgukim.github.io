---
title: 백준 17390번 이건 꼭 풀어야 해
layout: post
tags: [cpp]
---
### 문제 개요
> 숭실골 높은 언덕 깊은 골짜기에 출제로 고통 받는 욱제가 살고 있다!
> 욱제는 또 출제를 해야 해서 단단히 화가 났다. 그래서 욱제는 길이 N짜리 수열 A를 만들고, A를 비내림차순으로 정렬해서 수열 B를 만들어 버렸다!! 여기서 B를 출력하기만 하면 문제가 너무 쉬우니까 하나만 더 하자. 아래와 같은 질문이 무려 Q개나 주어진다!! (ㅎㅎ;; ㅈㅅ.. ㅋㅋ!!)
> L R: BL + BL+1 + ... + BR-1 + BR 을 출력한다.
>
> 욱제의 질문에 답하고 함께 엠티를 떠나자!!
>
> 첫 번째 줄에 수열 A의 길이 N과 질문의 개수 Q가 공백으로 구분되어 주어진다. (1 ≤ N, Q ≤ 300,000)
> 두 번째 줄에 N개의 정수 A1, A2, ..., AN 이 공백으로 구분되어 주어진다. Ai 는 수열 A의 i 번째 수이다. (1 ≤ Ai ≤ 1,000)
> 세 번째 줄부터 Q개의 줄에 걸쳐 욱제의 질문을 의미하는 두 수 L, R이 공백으로 구분되어 주어진다. (1 ≤ L ≤ R ≤ N)
> 주어지는 모든 입력은 자연수이다.
> 
> Q개의 줄에 걸쳐, 질문의 답을 순서대로 각각 출력한다.

### 정렬한 후 조작하고 출력
그냥 여러번 반복문을 돌리자니 뻔하게 시간초과인 문제다. 다행히 수열을 건너뛰고 출력하라는 말이 없으니, 대충 배열을 건드리면 된다.
### 코드
```c++
#include <iostream>
#include <algorithm>
using namespace std;

int N, M;//첫 줄 입력
int arr[300001] = { 0, };//배열. 편의상 300001로 설정하고 0으로 초기화

int main(){
	ios::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);

	cin >> N >> M;
	for (int i = 1; i <= N; i++) cin >> arr[i];//배열 인덱스 1부터 N까지 각각 원소 삽입
	sort(arr + 1, arr + N + 1);//그 원소들에 대해 오름차순 정렬
	for (int i = 2; i <= N; i++) arr[i] += arr[i - 1];//인덱스 2부터는 이전 배열의 원소를 더해주게 되면 각 인덱스의 합은 인덱스 1부터 n까지의 합이 됨.
	while(M--){//입력 받고 출력할 반복문
		int k1, k2;//일단 입력 받을 변수
		cin >> k1 >> k2;//입력 받아주고
		cout << arr[k2] - arr[k1 - 1] << '\n';//정렬된 원본 배열의 k1부터 k2까지의 합은 arr[k2] - arr[k1 -1]이 된다. 이걸 출력.
	}
}
```
### 해설
이중으로 반복문을 돌리면 무조건 시간초과가 날 설계다. 이럴땐 각 원소까지의 합을 간단히 다시 배열 형태로 저장하고,(이 경우엔 그냥 원 배열에 덮어씀)  
그걸 이용해 원하는 위치까지의 합에서 시작 위치 이전까지의 합을 뺀걸 출력하면 풀린다.  
### 여담
cin/cout 입출력구문을 쓰려면 미리 추가적으로 입출력 속도 개선 구문을 써줘야 했다.
