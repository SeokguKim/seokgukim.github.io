---
title: 백준 20206번 기하학
layout: post
tags: [cpp]
---
### 문제 개요
> 첫째 줄에는 정수 A, B, C (-10,000 ≤ A, B ≤ 10,000, -100,000 ≤ C ≤ 100,000)가 주어진다.  
> 해당 숫자들은 좌표 평면 상에서 Ax+By+C=0 형태로 표현되는 푸앙이가 지나가는 직선 상의 경로을 나타낸다.  
> (단 A, B 모두가 0인 경우는 직선의 방정식이 아니므로 주어지지 않는다.)  
> 둘째 줄에는 정수 X1, X2, Y1, Y2 (-100,000 ≤ X1 < X2 ≤ 100,000, -100,000 ≤ Y1 < Y2 ≤ 100,000) 이 주어진다.   
> 직사각형의 테두리들은 x = X1, x = X2, y = Y1, y = Y2 에 해당하는 직선에 포함된다.
> 첫째 줄에 푸앙이가 위험지역을 통과하면 “Poor”를, 통과하지 않으면 “Lucky”을 출력하라.  
> 위험 지역의 모서리만 통과하거나, 테두리 위로만 지나가는 경우는 위험지역을 통과하지 않는 것으로 간주한다.

### 이게 왜 어렵냐

보자마자 이건 진짜 별거 아니라고 생각했고 **실제로도 그랬다.**

하지만 언제나 그렇듯이 이상한 곳에서 헤맸다.
### 코드
```c++
#include <iostream>

using namespace std;

double N, M, O;//이 망할 그래프는 double형으로 선언해주지 않으면 틀린걸로 치더라
double xrng[2];//그래서 위험구역 좌표도 double로 선언, x좌표
double yrng[2];//위험구역 y좌표
int cnt = 0;//카운터

int main()
{	
	cin >> N >> M >> O;
	for (int i = 0; i < 2; i++) {
		cin >> xrng[i];
	}
	for (int i = 0; i < 2; i++) {
		cin >> yrng[i];
	}
  /*입력 받기*/

	if (yrng[0] <= -(N * xrng[0] + O) / M && -(N * xrng[0] + O) / M <yrng[1]) {
		cnt++;
	}
	if (yrng[0] < -(N * xrng[1] + O) / M && -(N * xrng[1] + O) / M <= yrng[1]) {
		cnt++;
	}
	if (xrng[0] < -(M * yrng[0] + O) / N && -(M * yrng[0] + O) / N <= xrng[1]) {
		cnt++;
	}
	if (xrng[0] <= -(M * yrng[1] + O) / N && -(M * yrng[1] + O) / N < xrng[1]) {
		cnt++;
	}
  /*간단하게 그래프가 위험구역의 각 변을 지나는 경우 카운트를 하게 if문. 범위가 겹치지 않도록 해야 하고 어차피 4케이스라 그냥 if문 떡칠)*/

	if (cnt > 1) {//카운터가 0일땐 안 지나가고, 1일땐 접점이나 변 위로 지나가는 것이므로 Lucky, 2인 경우는 확실히 지나므로 Poor
		cout << "Poor";
	}
	else {
		cout << "Lucky";
	}
}
```
### 해설
별거 없다.

그냥 1차 방정식 그래프와 도형의 성질을 생각하면 직선이 정사각형을 지날때 2개의 접점이 있든 1개의 접점이 있든 접점이 없든 무한하든 넷 중 하나다.  
이 때 1개인 경우는 모서리를 지나가고 0개인 경우는 안 지나가며, 무한한 경우 변과 겹치고 **2개일때 내부를 가로지르게 된다.**  
이걸 이용해서 접점 수를 구하는 if문을 세우고 무한한 경우는 제외하고 접점이 2개 이상인 경우 Poor가 나오게 하면 된다.
### 여담
난 정수형을 좋아하기 때문에 처음엔 그냥 이항정리 해서 변수를 정수로 두는 선에서 처리하려 했다.

**근데 계속 안되더라고.**

분명 식도 맞고 예외처리도 잘 하고 결과값도 잘 나오는데 왜 안 되지 하면서 변수를 실수인 double 형으로 바꿨더니...

**그냥 됐다.**

솔직히 너무 손해본 느낌이다. 이건 문의사항으로 올려야지.
