---
title: 백준 10655번 마라톤
layout: post
tags: [cpp]
--
### 문제 재요
> 농장에 있는 젖소들이 건강하지 못하다고 생각한 농부 존은 젖소들을 위한 마라톤 대회를 열었고, 농부 존의 총애를 받는 젖소 박승원 역시 이 대회에 참가할 예정이다.  
> 마라톤 코스는 N (3 ≤ N ≤ 100000) 개의 체크포인트로 구성되어 있으며, 1번 체크포인트에서 시작해서 모든 체크 포인트를 순서대로 방문한 후 N번 체크포인트에서 끝나야지 마라톤이 끝난다. 게으른 젖소 박승원은 막상 대회에 참가하려 하니 귀찮아져서 중간에 있는 체크포인트 한개를 몰래 건너뛰려 한다. 단, 1번 체크포인트와 N번 체크포인트를 건너뛰면 너무 눈치가 보이니 두 체크포인트는 건너뛰지 않을 생각이다.  
> 젖소 박승원이 체크포인트 한개를 건너뛰면서 달릴 수 있다면, 과연 승원이가 달려야 하는 최소 거리는 얼마일까?  
> 참고로, 젖소 마라톤 대회는 서울시내 한복판에서 진행될 예정이기 때문에 거리는 택시 거리(Manhattan Distance)로 계산하려고 한다. 즉, (x1,y1)과 (x2,y2) 점 간의 거리는 |x1-x2| + |y1-y2| 로 표시할 수 있다. (|x|는 절댓값 기호다.)  
> 
> 첫 번째 줄에 체크포인트의 수 N이 주어진다.  
> 이후 N개의 줄에 정수가 두개씩 주어진다. i번째 줄의 첫 번째 정수는 체크포인트 i의 x좌표, 두 번째 정수는 y좌표이다. (-1000 ≤ x, y ≤ 1000)  
> 체크 포인트의 좌표는 겹칠 수도 있다 - 젖소 박승원은 체크포인트를 건너뛸 때 그 번호의 체크포인트만 건너뛰며, 그 점에 있는 모든 체크포인트를 건너뛰지 않는다.  
> 
> 젖소 박승원이 체크포인트 1개를 건너뛰고 달릴 수 있는 최소 거리를 출력하라.

### 줄어드는 거리의 최대값
경우의 수를 모두 시도하는 방법도 있지만, 요놈의 시간제한 때문에 그렇게 풀면 안 풀린다.
중간에 있는 체크포인트를 건너뛸때 줄어드는 거리를 계산해, 그게 최대값인 체크포인트를 건너뛴다.
### 코드
```c++
#include <iostream>

using namespace std;

int main()
{
	int N, ans = 0, dis, jumpdis, diff, idx, pre, now = 0;
	int rarr[100000], carr[100000];
  //변수 선언
	cin.tie(NULL); cout.tie(NULL);
	ios::sync_with_stdio(false);

	cin >> N;

	for (int i = 0; i < N; i++) {
		cin >> rarr[i] >> carr[i];
	}
  //입력
	for (int i = 1; i < N - 1; i++) {
		dis = abs(rarr[i] - rarr[i - 1]) + abs(carr[i] - carr[i - 1]) + abs(rarr[i + 1] - rarr[i]) + abs(carr[i + 1] - carr[i]);//i번 체크포인트를 거쳐 i -1 번에서 i + 1번으로 가는 거리
		jumpdis = abs(rarr[i + 1] - rarr[i - 1]) + abs(carr[i + 1] - carr[i - 1]);//i - 1번에서 i + 1번으로 직통 거리
		if (i == 1 || diff < dis - jumpdis) {//줄어드는 거리가 최대일때
			diff = dis - jumpdis;//갱신
			idx = i;//인덱스 저장
		}
	}
	for (int i = 1; i < N; i++) {//idx 제외하고 합산
		if (i != idx) {
			pre = now;
			now = i;
			ans += abs(rarr[now] - rarr[pre]) + abs(carr[now] - carr[pre]);
		}
	}
	cout << ans;
}
```
### 해설
1개의 체크포인트만 건너뛰면서 최소 거리를 구하라는건, 줄이는 거리가 최대인 체크포인트를 찾으라는 것.  
i번째 체크포인트(1 <= i <= N-1)에 대해 통상 진행의 거리와 해당 체크포인트를 생략했을때의 거리를 구하고, 이게 미리 지정된 값보다 크면 갱신한다.  
반복문 끝까지 가면 최대로 줄어드는 체크포인트의 인덱스가 구해지고, 그걸 제외하고 거리를 합산하는 반복문을 세웠다.
### 여담
처음엔 3중 for문으로 둘러싸서 대충 하나하나 생략했을때의 끝까지의 거리를 다 구하여 비교하는 식으로 코드를 작성했다.  

**결과값은 맞지만 시간 초과.**

따라서 최대 감축 거리를 구하는 식으로 코드를 바꿨다.  
*항상 드는 생각이지만 컴퓨팅 파워는 넘쳐나는데 굳이 이래야 할까.*
