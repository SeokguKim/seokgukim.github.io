---
title: 백준 22114번
layout: post
tags: [cpp]
---
### 문제 개요
>> 첫째 줄에 빨간 보도블럭의 개수 N, 창영이의 보폭 K가 주어진다.
둘째 줄에 각 빨간 보도블럭 사이의 거리 Li가 N-1개 주어진다.
시작점을 임의로 설정하고 점프를 최대 한 번 할 수 있을 때, 창영이가 연속해서 밟을 수 있는 빨간 보도블럭의 최대 개수를 출력한다.
2 ≤ N ≤ 100,000
1 ≤ K, Li ≤ 100

### 투 포인터를 쓰라고?

C++로는 처음 풀어보는 문제.

일단 문제 알고리즘의 분류는 투 포인터. 포인터 2개로 반복문의 값을 조작하는 문제다.
시간제한이 넉넉한 편이기에, 그냥 반복문을 이중으로 돌렸다.

### 코드
```
#include <iostream>

using namespace std;

int board[100001];

int main()
{
    int N, M;
    cin >> N >> M;

    for (int i = 0; i < N-1; i++)
        cin >> board[i];
    /* 입력 받기. */
    int answer = 0;
    /* answer에 답 저장 */
    for (int k = 0; k < N-1; k++)
    {
        int tmp = 1;
        int chk = 1;
        /* 임시변수 초기화 */
        for (int j = k; j < N-1; j++)
        {
            if (board[j] <= M){   
                tmp++;
                /* 그냥 건너질때 */
            }
            else {
                if (chk > 0){
                    tmp++;
                    chk = 0;
                    /* 점프가 가능한 경우 */
                }
                else{
                    break;
                    /* 점프가 불가능한 경우 */
                }
            }
        }
        if (tmp > answer){
            answer = tmp;
            /* 최대값 비교 */
        }
    }
    cout << answer;
    /* 출력 */
}
```

### 해설

일단 자료입력 구조는 처음 두 수 N과 M을 인자로 입력한 다음 배열 자료형을 받는다.

이 때 N이 100,000 까지이므로, 배열 크기는 넉넉잡고 100001로 설정했다.

중간에 답을 저장할 전역변수 answer를 설정한 후, N-1개의 각각의 시작점에서 점프를 1번 써서 갈 수 있는 기록을 구하는 반복문을 세웠다.

여기서 보폭으로 통과가 되면 그냥 임시변수 tmp에 더하고, 점프를 쓰는 경우 tmp에 더하면서 동시에 1이었던 chk가 0이 되며 다시 점프를 못하게 된다.

tmp와 chk는 다음 시작점으로 넘어가면 초기화되고, 이런 구조를 반복하도록 했다.

### 여담

처음엔 귀찮게 배열을 한 번 더 쓰고 점프 없이 연속으로 갈 수 있는 블록 수를 합산하는 방식으로 돌리다가 멋지게 틀려버렸다.

**되게 복잡했는데 시간초과가 안 난건 신기하다. 역시 시간 널널하게 줬네.** 

그래서 그냥 시간은 신경 안 쓰고 대충 맞겠지 싶은 저 코드를 짰고.

하지만 지역변수 선언 위치가 잘못되어서 chk가 0이 되어야 하는데 자꾸 초기화되는걸 모르고 1시간은 붙잡고 있었다.

다음부턴 그런 실수 안 해야지.

