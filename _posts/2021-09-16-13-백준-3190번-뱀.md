---
title: 백준 3190번 뱀
layout: post
tags: [cpp]
---
### 문제 개요
> 'Dummy' 라는 도스게임이 있다. 이 게임에는 뱀이 나와서 기어다니는데, 사과를 먹으면 뱀 길이가 늘어난다. 뱀이 이리저리 기어다니다가 벽 또는 자기자신의 몸과 부딪히면 게임이 끝난다.
> 게임은 NxN 정사각 보드위에서 진행되고, 몇몇 칸에는 사과가 놓여져 있다. 보드의 상하좌우 끝에 벽이 있다. 게임이 시작할때 뱀은 맨위 맨좌측에 위치하고 뱀의 길이는 1 이다. 뱀은 처음에 오른쪽을 향한다.
> 뱀은 매 초마다 이동을 하는데 다음과 같은 규칙을 따른다.
> 1. 먼저 뱀은 몸길이를 늘려 머리를 다음칸에 위치시킨다.
> 2. 만약 이동한 칸에 사과가 있다면, 그 칸에 있던 사과가 없어지고 꼬리는 움직이지 않는다.
> 3. 만약 이동한 칸에 사과가 없다면, 몸길이를 줄여서 꼬리가 위치한 칸을 비워준다. 즉, 몸길이는 변하지 않는다.
> 4. 사과의 위치와 뱀의 이동경로가 주어질 때 이 게임이 몇 초에 끝나는지 계산하라.
> 
> 첫째 줄에 보드의 크기 N이 주어진다. (2 ≤ N ≤ 100) 다음 줄에 사과의 개수 K가 주어진다. (0 ≤ K ≤ 100)
> 다음 K개의 줄에는 사과의 위치가 주어지는데, 첫 번째 정수는 행, 두 번째 정수는 열 위치를 의미한다. 사과의 위치는 모두 다르며, 맨 위 맨 좌측 (1행 1열) 에는 사과가 없다. 
> 다음 줄에는 뱀의 방향 변환 횟수 L 이 주어진다. (1 ≤ L ≤ 100)
> 다음 L개의 줄에는 뱀의 방향 변환 정보가 주어지는데,  정수 X와 문자 C로 이루어져 있으며. 게임 시작 시간으로부터 X초가 끝난 뒤에 왼쪽(C가 'L') 또는 오른쪽(C가 'D')로 90도 방향을 회전시킨다는 뜻이다. X는 10,000 이하의 양의 정수이며, 방향 전환 정보는 X가 증가하는 순으로 주어진다.
> 
> 첫째 줄에 게임이 몇 초에 끝나는지 출력한다.

### deque을 이용하자
문제 설명이 꽤나 세세하다. 문제에 설명된 순서를 덱으로 잘 구현하면 될 것 같았다.
### 코드
```c++
#include<iostream>
#include <deque>

using namespace std;

int N, K, D, T = 0, idc = 0;///N에 보드크기, K에 사과개수, D에 방향전환 수, T는 시간, idc는 방향 지정
int board[102][102] = { 0, };// 편의상 보드 가장자리에 탈출구간을 만들려 102 크기로 보드 선언
deque<pair<int, char>> dc; deque <pair<int, int>> snake;//방향 변경 정보를 받을 덱 dc와 뱀의 정보를 저장할 snake
int di[4][2] = { {0,1},{1,0},{0,-1},{-1,0} };//이동을 조정할 배열. idc의 초기 인자 0일땐 우측 이동이며 나머진 시계 방향대로 넣음

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    cin >> N >> K;
    for (int i = 1; i <= N; i++) for (int j = 1; j <= N; j++) board[i][j] = 1;//입력 받고 보드의 N*N영역에 대해선 1을 할당. 1이 빈 공간이란 뜻 
    for (int i = 0; i < K; i++) {//사과 좌표를 입력받고 보드의 해당 좌표에 대해 사과가 있다는 뜻으로 2를 할당
        int a, b;
        cin >> a >> b;
        board[a][b] = 2;
    }
    cin >> D;
    for (int i = 0; i < D; i++) {//방향 전환 정보를 pair형으로 dc 덱에 넣어줌
        int a; char b;
        cin >> a >> b;
        dc.push_back(make_pair(a, b));
    }
    snake.push_back(make_pair(1, 1)); board[1][1] = 0;//초기 뱀 위치인 (1, 1)을 snake에 삽입하고 해당 위치를 0으로 만들어 진행 불가를 표시
    while (1) {//매 단위 시간에 대해
        T++;//일단 시간 증가
        int a = snake.front().first + di[idc][0], b = snake.front().second + di[idc][1];//머리의 새 위치를 a, b에 받음
        if (board[a][b] == 0) break;//만약 못가는 위치면 탈출
        snake.push_front(make_pair(a, b));//그렇지 않다면 여기 와서 snake 덱 맨 앞에 해당 좌표를 추가
        if (dc.size()) {//단위시간 맨 마지막에 전환이지만 컨티뉴문 쓸 것이므로 안 꼬이는 적당한 위치에 넣음. 방향전환 할거 남았을때
            if (T == dc.front().first) {//전환할 시간 순서대로 입력되므로 그냥 덱의 맨 앞 원소를 기준으로 현재 시간과 전환 타이밍이 일치하면
                if (dc.front().second == 'D') {//D일때 우회전. idc가 4가 되면 0으로 초기화되게 했음
                    idc++; if (idc == 4) idc = 0;
                }
                else {//L일때 좌회전. idc가 -1이 되면 3으로 초기화되게
                    idc--; if (idc == -1)idc = 3;
                }
                dc.pop_front();//방향전환 했으면 맨 앞 원소는 지워버림
            }
        }
        if (board[a][b] == 2) {//이동한 칸에 사과가 있는 경우
            board[a][b] = 0; continue;//머리가 왔으니 해당 칸에 대해서 지나갈 수 없단 뜻의 0을 할당. 그리고 뒤의 꼬리 조정 안하고 컨티뉴
        }
        board[a][b] = 0;//아닌 경우에도 머리가 온 칸에 대해선 지나갈 수 없단 뜻의 0 할당
        board[snake.back().first][snake.back().second] = 1;//snake 덱 맨 마지막 원소가 꼬리가 되므로, 해당 원소가 가리키는 좌표를 빈 공간인 1로 수정
        snake.pop_back();//꼬리 삭제
    }
    cout << T;//탈출했으면 출력
}
```
### 해설
일단 입력을 다 받은 다음 덱에 뱀의 위치 정보에 대해 받고, 보드는 지나갈 수 있는 경우 1, 사과가 있으면 2, 못 지나가면 0의 상태가 갱신되도록 했다.  
이동 이후 방향 전환 여부를 판단해준다. idc에 현재 방향 정보를 받고, 우회전과 좌회전에 대응할 수 있도록 인덱스를 움직여 배열 di로부터 가져온다.  
맨 마지막에 방향 전환을 한다고 문제 설명에 있지만, 어차피 이 이후 이동은 안 하므로 여기서 전환해도 상관없을 뿐더러, 뒤의 컨티뉴문을 생각하면 이 쯤에서 꼬이지 않게 전환해주자.
머리가 새 위치로 이동한 뒤 꼬리를 없애주며, 이 때 사과를 먹었으면 꼬리를 없애는 과정은 생략한다.  
이걸 벽이나 몸통에 박을때까지 반복한 후 탈출했을때의 T값을 출력해주면 된다.
### 여담
원래 저 방향 조정은 idc를 4로 나눈 나머지로 넣으면 되겠지 생각했지만, C++ 나누기 연산이 일반적인 나누기의 정의와 부합하지 않는 구조라 그렇게 하면 코드가 꼬여버렸다.  
따라서 그냥 임계점에서 값 초기화 하는 식으로 방향전환 루프 구조를 만들었다. 
  
