---
title: 백준 1051번 숫자 정사각형
layout: post
tags: [cpp]
---
### 문제 개요
> N×M크기의 직사각형이 있다. 각 칸은 한 자리 숫자가 적혀 있다. 이 직사각형에서 꼭짓점에 쓰여 있는 수가 모두 같은 가장 큰 정사각형을 찾는 프로그램을 작성하시오. 이때, 정사각형은 행 또는 열에 평행해야 한다.
> 
> 첫째 줄에 N과 M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 수가 주어진다.
> 
> 첫째 줄에 정답 정사각형의 크기를 출력한다.

### 그냥 하면 됨
그냥 하면 된다. 2차원 배열에 칸 정보를 집어넣고 변 길이가 가장 큰 정사각형부터 되는지 넣어보면 된다.
### 코드
```c++
#include<iostream>

using namespace std;

int N, M;
int field[50][50];//최대 변 크기는 50이니 대충 이리 선언

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);
	cin >> N >> M;
	for (int i = 0; i < N; i++) {//정사각형 정보 입력
		string a; cin >> a;//일단 스트링으로 받는다. 애들이 입력을 띄어쓰기 없이 줘서 어쩔 수 없음
		for (int j = 0; j < M; j++) field[i][j] = a[j];//인덱스대로 할당함. 어차피 0~9라 char형 나와도 꼬일 이유 없이 괜찮음
	}

	for (int mr = min(N, M); mr > 0; mr--) {//가능한 가장 큰 변의 길이(min(N, M))부터 1까지 
		for (int i = 0; i < N; i++) for (int j = 0; j < M; j++) {//모든 좌표에 대해
			if (i + mr > N || j + mr > M) continue;//그걸 좌상단으로 해서 만든 사각형 크기가 필드 벗어나면 컨티뉴
			if (field[i][j] == field[i + mr - 1][j] && field[i + mr - 1][j] == field[i][j + mr - 1] && field[i][j + mr - 1] == field[i + mr - 1][j + mr - 1]) {//꼭짓점 수가 같다면 
				cout << mr * mr; return 0;//출력하고 함수 종료
			}
		}
	}
}
```
### 해설
별 고민할 것도 없이 반복문 인자만 잘 조정해주면서 생략과 이탈만 해주면 된다.  
일단 가장 입력받은 정보를 토대로 가장 큰 정사각형을 만들 수 있는 경우부터 생각하면서 차근차근 내려오게 하고,  
일치하는 값이 있으면 출력하고 종료해버린다.
