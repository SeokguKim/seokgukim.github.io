---
title: 백준 12094번 2048 (Hard)
layout: post
tags: [cpp]
---
### 문제 개요
> **문제**
> 
> 2048 게임은 4×4 크기의 보드에서 혼자 즐기는 재미있는 게임이다.  
> 이 게임에서 한 번의 이동은 보드 위에 있는 전체 블록을 상하좌우 네 방향 중 하나로 이동시키는 것이다. 이때, 같은 값을 갖는 두 블록이 충돌하면 두 블록은 하나로 합쳐지게 된다. 한 번의 이동에서 이미 합쳐진 블록은 또 다른 블록과 다시 합쳐질 수 없다.  
> (실제 게임에서는 이동을 한 번 할 때마다 블록이 추가되지만, 이 문제에서 블록이 추가되는 경우는 없다)  
> 이 문제에서 다루는 2048 게임은 보드의 크기가 N×N 이다.   
> 보드의 크기와 보드판의 블록 상태가 주어졌을 때, 최대 10번 이동해서 만들 수 있는 가장 큰 블록의 값을 구하는 프로그램을 작성하시오.

> **입력**
> 
> 첫째 줄에 보드의 크기 N (1 ≤ N ≤ 20)이 주어진다. 둘째 줄부터 N개의 줄에는 게임판의 초기 상태가 주어진다.  
> 0은 빈 칸을 나타내며, 이외의 값은 모두 블록을 나타낸다. 블록에 쓰여 있는 수는 2보다 크거나 같고, 1024보다 작거나 같은 2의 제곱꼴이다. 블록은 적어도 하나 주어진다.

> **출력**
>
> 최대 10번 이동시켜서 얻을 수 있는 가장 큰 블록을 출력한다.

### 전에도 한번 풀었던 깡구현 문제
구현을 매우 열심히 해야하는 문제다.  
전에 Easy 버전을 풀었던 거에서 성능을 좀 더 향상시키기 위해, 벡터로 받던걸 배열로 받고, 덱을 안 써서 하니까 통과되더라.
### 코드
```c++
#include <iostream>
using namespace std;

int N, maxx;//maxx에 현재 전체 최대값
int board[20][20];//초기 보드 상태

bool same(int v[20][20], int v2[20][20]) {//보드가 같은지 판별하는 함수
    for (int i = 0; i < N; i++) for (int j = 0; j < N; j++) if (v2[i][j] != v[i][j]) return false;//상태가 하나라도 다르면 false
    return true;//다 같으면 true
}

int mypow(int n) {//2의 제곱 함수
    int res = 1;
    while (n--) res <<= 1;
    return res;
}

void move(int cnt, int cmax, int v[20][20]) {//움직임 구현
    if (!cnt) return;//남은 이동 횟수가 없다면 끝
    for (int k = 0; k < 4; k++) {//4방향 이동에 대해서
        int nb[20][20] = { 0, };//일단 새로운 보드의 배열은 전부 0으로 초기화
        int start = k & 1 ? N - 1 : 0, end = k & 1 ? -1 : N, delta = k & 1 ? -1 : 1;//음/양의 방향 기준으로 패러미터들 설정
        int ccmax = 0;//현재 부분 최대값
        for (int i = 0; i < N; i++) {//N개의 행 또는 열에 대해
            bool flg = 0;//합칠 수 있는가에 대한 변수
            int rptr = k & 1 ? N - 1 : 0;//현재 밀어넣어주는 좌표
            for (int j = start; j != end; j += delta) {//해당 행 또는 열을 모두 보면서
                int tmp = k > 1 ? v[i][j] : v[j][i];//종횡 방향에 맞게 원소를 봄
                int& cur = k > 1 ? nb[i][rptr] : nb[rptr][i];//종횡 방향에 맞게 목적지를 설정
                    if (tmp) {//원소가 0이 아니면 밀어넣을 수 있으므로
                        if (flg) {//합칠 수 있다 한다면
                            int& pre = k > 1 ? nb[i][rptr - delta] : nb[rptr - delta][i];//이전 좌표를 가져옴
                            if (pre == tmp) {//이전 좌표의 값과 현재 값이 일치하면
                                flg = 0;//다음은 합칠 수 없고
                                pre <<= 1;//합쳐진 이전 좌표는 값이 2배가 됨
                                ccmax = max(pre, ccmax);//갱신된 값과 현재 최대값 비교
                                continue;//다음 좌표로
                            }
                        }
                        cur = tmp, rptr += delta, flg = 1;//앞 경우에 해당하지 않는다면 현재 좌표에 밀어넣고 좌표를 진행시키며 합칠 수 있게 함
                        ccmax = max(cur, ccmax);// 갱신된 값과 현재 최대값 비교
                    }
            }
        }
        maxx = max(maxx, ccmax);//현재 최대값과 전체 최대값 비교
        if (same(nb , v)) continue;//판 상태가 같다면 더는 진행할 이유 없음
        if (mypow(cnt - 1) * ccmax > maxx) move(cnt - 1, ccmax, nb);//현재 최대값과 2^남은 횟수를 곱해 얻는 이론상 최대값을 비교해 최대값이 갱신될 가능성이 있는 경우에만 재귀
    }
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin >> N;
    for (int i = 0; i < N; i++)for (int j = 0; j < N; j++) cin >> board[i][j], maxx = max(maxx, board[i][j]);
    move(10, maxx, board);
    cout << maxx;
}
```
### 여담
덱이나 벡터 같은걸 쓰면 코드가 깔끔해지고 이해가 쉽게 되는데 속도가 안 따라줬다.  
그냥 배열로 해결.
