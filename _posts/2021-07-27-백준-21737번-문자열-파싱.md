---
layout: post
title: 백준 21737번 문자열 파싱
tags: [cpp]
---

### 문제 개요

> 첫째 줄에 수식에 들어갈 기호의 개수 N (1 <= N <= 500,000) 이 주어진다.  
둘째 줄에 개의 기호가 사용된 수식이 주어진다. 수식의 길이는 1,000,000을 넘지 않는다.  
단, 계산 도중 입력되는 수나 계산 결괏값의 범위는  -2^31이상  2^31-1이하이다.  
더불어 어떤 수를 0으로 나누는 경우는 존재하지 않는다.

### 문자 나누고 뭘 더 해야 하는 귀찮은 문제

이번 문제는 상당히 귀찮다. 나눠줘야 하는 경우의 수가 많기 때문.

문제 자체가 요구하는 알고리즘을 구상하는데는 그리 오래 걸리지 않았지만  실제로 만드는데는 뻑나기 좋은 코드였다.

### 코드

```c++
#include <iostream>
#include <cstring>

using namespace std;
int opr = 4; //초기 연산자 값, "+"

int main()
{
    int N;
    string str;

    cin >> N; //왜 있는지 모르겠는 기호 수 입력
    cin >> str; //문자열 입력

    int num = 0; //임시변수로 저장
    int ans = 0; //계산 결과 저장
    bool chk = false; //"C" 가 나왔는가?

    for (int i = 0; i < str.length(); i++) {  

        if (str[i] > 47 && str[i] < 58) { //아스키 코드를 이용해 문자열 구분
            num = num * 10 + str[i] - 48;
        }
        else {
            if (opr == 1) {
                ans -= num;
            }
            else if (opr == 2) {
                ans *= num;
            }
            else if (opr == 3) {
                ans /= num;
            }
            else if (opr == 4) {
                ans += num;
            }

            if (str[i] == 83) { //"-"
                opr = 1;
            }
            else if (str[i] == 77) { //"*"
                opr = 2;
            }
            else if (str[i] == 85) { //"/"
                opr = 3;
            }
            else if (str[i] == 80) { // "+"
                opr = 4;
            }
            else if (str[i] == 67) { // "출력"
                chk = true;
                opr = 4;
                cout << ans << ' ';
            }
            num = 0;
        }
    }
    if (!chk){
        cout << "NO OUTPUT"; //출력 안됨
    }
}
```

### 해설

일단 아스키 코드 선에서 해결될 문제라 생각해 그냥 아스키 코드로 입력을 변환한 다음,  
숫자는 십진법으로 입력받고 문자는 연산자 조건문으로 보냈다.  
그리고 다음번 연산자가 나올 때 연산을 처리하는 방식으로 구현되었다.

### 여담

처음에는 그냥 어차피 저 bool형의 변수로 C가 나왔나의 여부를 나중에 체크하는게 아니라  그냥 냅다 문자열 검색인 strchr을 이용해 C가 있는지 여부를 먼저 돌리고 메인 함수를 돌렸다.

그래서인지 자꾸 내가 짠 코드는 맞게 돌아가는데도 틀렸다는 메시지 뿐...  결국 다른 풀이를 봤더니 내가 한 거랑 그렇게 차이는 나지 않으면서도 bool형 변수로 출력을 조정하고 있는 것을 발견해 도입했더니 이번엔 또 **시간 초과.**

그래서 복잡도 개선을 위해 원래 외부 함수로 처리하던 연산 부분을 if문 안으로 끌어들이니 저렇게 되었다. 아무래도 기계가 하는 채점이다 보니... 기계 장단에 맞춰줘야 하는건 언제나 귀찮다.







