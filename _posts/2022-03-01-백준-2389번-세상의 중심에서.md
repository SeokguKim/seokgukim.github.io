---
title: 백준 2389번 세상의 중심에서
layout: post
tags: [cpp]
---
### 문제 개요
> 위대한 뮤지션 김동혁은 그의 팬들을 위한 공연을 하기로 하였다. 그는 관객과 함께하는 공연을 기획하기 위해 원형 모양의 콘서트홀을 만들기로 하였다.  
> N명의 팬들은 (x, y)좌표를 갖는 곳에 있다. 김동혁은 N명의 사람들을 모두 포함하는 원(원의 경계에 있는경우도 포함하는 경우로 치자)의 가운데에서 공연을 하려 한다. 이때 원의 반지름을 최소 얼마로 하면 되겠는가?  
> 김동혁이 세상의 중심에서 락을 외칠 수 있도록 도와 주는 프로그램을 작성해 보자.  
> 첫째 줄에 N(1≤N≤100)이 주어진다. 다음 N개의 줄에는 x, y 좌표가 주어진다. 각각의 좌표는 소수점 여섯째자리까지 주어지며, -600,000 ≤ x, y ≤ 600,000을 만족한다.  
> 첫째 줄에 김동혁의 x좌표, y좌표, 원의 반지름을 출력한다. 절대/상대 오차는 10-3까지 허용한다.

### 최소외접원
문제의 설명에 의하면, 모든 사람들을 포함하는 원의 가운데에서 공연을 하게 되므로,  
점들의 최소외접원의 중심 좌표와 반지름을 구하면 된다는 사실 자체는 금방 떠올릴 수 있었다.  
일단 이번에 적용된 이론은 다음과 같다.

[최소외접원 알고리즘 관련 논문 링크](http://dspace.mit.edu/bitstream/handle/1721.1/4015/HPCES024.pdf?sequence=2)

완벽하게 이해했다! ...라고는 못하겠지만,  
기본적으로 입력받은 점들의 x좌표와 y좌표의 평균값을 중심점으로 삼은 후 모든 점 좌표와의 거리를 대조해 가면서  
만약 이전의 최대 거리보다 크다면 최소외접원은 그 크기 이상이라는 말이 되므로 중심점의 좌표를 조정해주는 식인 것이다.  
결국 그렇게 하다보면 최소외접원에 수렴하는 결과가 나온다는 것이 포인트.
### 코드
```c++
#include <iostream>
#include <math.h>
#include <vector>
using namespace std;

double dist(double a, double b) {//거리 계산 함수. 처음엔 단순히 대소비교만 해도 되니 루트 연산은 출력할떄 하기로 한다.
	return a * a + b * b;
}

int N;//점 개수인 N
double D, TD, X, Y;//점 사이의 최대 거리를 저장해 줄 D, 두 점 사이 거리 계산에 쓰일 변수 TD, 외접원 중심점 좌표가 될 X, Y

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);

	cin >> N;
	vector<pair<double, double>> v;//입력받을 벡터
	for (int i = 0; i < N; i++) {
		double a, b;
		cin >> a >> b;
		v.emplace_back(a, b);
		X += a, Y += b;
	}
	X /= N, Y /= N;//초기 중심점은 모든 점 좌표의 평균값으로 설정
	double p = 0.1;
	for (int i = 0; i < 30000; i++) {
		int f = 0;
		D = dist(X - v[0].first, Y - v[0].second);
		for (int j = 1; j < N; j++) {
			TD = dist(X - v[j].first, Y - v[j].second);
			if (D < TD) { 
				D = TD, f = j; 
			}
		}
    //거리를 계산해 더 큰 외접원이 존재한다면 갱신
		X += (v[f].first - X) * p;
		Y += (v[f].second - Y)  *p;
		p *= 0.999;
    //중심점의 좌표를 조정
	}
	cout << fixed;
	cout.precision(4);
  //소수점 4자리까지 출력
	cout << X << "\n" << Y << "\n" << sqrt(D);
}
```
