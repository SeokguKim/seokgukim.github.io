---
title: 백준 21735번 눈덩이 굴리기
layout: post
tags: [cpp]
---
### 문제 개요

>눈덩이를 현재 위치 +1칸으로 굴린다. 
>현재 칸의 위치를 a(i)라고 하면 눈덩이의 크기는 a(i+1)만큼 늘어난다.  
>눈덩이를 현재 위치 +2칸으로 던진다.  
>눈덩이가 착지하며 충격을 받아 눈덩이의 크기는 원래의 크기의 반으로 줄어들고  
>현재 칸의 위치를 a(i)라고 하면 눈덩이의 크기는 a(i+2)만큼 늘어난다. 이 때 소수점은 절사한다. 
>눈덩이를 던져 크기가 이 되어도 눈덩이는 사라지지 않는다.
>첫째 줄에 공백을 기준으로 앞마당의 길이  N(1 <= N <= 100), 대회의 시간  M(1 <= M <= 10)이 주어진다.  
>둘째 줄에 길이가 N인 수열 a가 주어진다. (1 <= a(i) <= 1,000,000)  
>첫째 줄에 대회 시간 내에 가장 크게 만들 수 있는 눈덩이의 크기를 출력한다.

### 브루트포스라고 했지만 난 큐 쓸거다

문제 분류로는 브루트포스 알고리즘을 칭하고 있다.

**대충 노가다 하란 뜻.**

하지만 큐를 쓰면 이런 경우의 수 탐색 문제는 더 쉬울 것 같았다.

### 코드
```c++
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int N, M;
vector<int> field;//벡터에 마당 정보 받음
int ans=1;//눈덩이 크기
int main()
{	
	cin >> N >> M;
	field.push_back(1);//벡터 범위 조정용
	for (int i = 0; i < N; i++) {
		int temp;
		cin >> temp;
		field.push_back(temp);//벡터에 하나씩 넣기
	}
	queue <vector<int>> q;//큐 선언
	q.push({ 0,0,1 });//큐에 벡터 넣기([0]은 경과 시간, [1]은 좌표, [2]는 현재 눈덩이 크기)

	while (!q.empty()) {
		if (q.front()[0] < M && q.front()[1] + 1 <= N) {
			q.push({ q.front()[0] + 1,q.front()[1] + 1, q.front()[2] + field[q.front()[1] + 1]});//굴릴때를 큐에 추가
		}
		if (q.front()[0] < M && q.front()[1] + 2 <= N) {
			q.push({ q.front()[0] + 1,q.front()[1] + 2, q.front()[2]/2 + field[q.front()[1] + 2]});//던질때를 큐에 추가
		}
		if (q.front()[2] > ans) {//해당 케이스의 눈덩이 크기가 저장된 최대 크기보다 크면
			ans = q.front()[2];//값 대체
		}
		q.pop();//큐 원소 제거
	}
	cout << ans;
}
```
### 해설

하나하나 배열 만들고 저장할 필요 없이 큐로 돌면서 해결이 되게 했다.

일단 큐에 시작점의 경과 시간(0), 좌표(0), 크기(1)를 넣고,  
굴렸을때와 던졌을때의 케이스가 가능한 경우 큐에 추가해주면서 큐의 눈덩이 크기 속성이 저장된 최대값보다 크면 갱신하게 만들었다.

### 여담

![와!](https://user-images.githubusercontent.com/43718966/127743456-3abe0d4b-209a-4241-b187-06e02f818327.png)


아무 레퍼런스도 안 보고 그냥 대충 외운걸로 했는데 **한번에 맞춘 문제.**

실력이 안 늘지는 않은 모양이다.

중간에 반복문 범위 잘못 설정해서 좀 고친거 빼면 초기 구상에서 진짜 거의 수정도 안 했다.



