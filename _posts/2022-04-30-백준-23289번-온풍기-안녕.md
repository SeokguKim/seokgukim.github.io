---
title: 백준 23289번 온풍기 안녕
layout: post
tags: [cpp]
---
### 문제 개요
> 유난히 추운 날씨가 예상되는 이번 겨울을 대비하기 위해 구사과는 온풍기를 설치하려고 한다. 온풍기의 성능을 테스트하기 위해 구사과는 집을 크기가 R×C인 격자판으로 나타냈고, 1×1 크기의 칸으로 나눴다. 구사과는 뛰어난 코딩 실력을 이용해 각 칸 (r, c)의 온도를 실시간으로 모니터링하는 시스템을 개발했다. (r, c)는 r행 c열을 의미한다.
> 
> 구사과의 성능 테스트는 다음과 같은 작업이 순차적으로 이루어지며, 가장 처음에 모든 칸의 온도는 0이다. 문제의 그림에서 빈 칸은 온도가 0인 칸을 의미한다.
> 
> 1. 집에 있는 모든 온풍기에서 바람이 한 번 나옴
> 2. 온도가 조절됨
> 3. 온도가 1 이상인 가장 바깥쪽 칸의 온도가 1씩 감소
> 4. 초콜릿을 하나 먹는다.
> 5. 조사하는 모든 칸의 온도가 K 이상이 되었는지 검사. 모든 칸의 온도가 K이상이면 테스트를 중단하고, 아니면 1부터 다시 시작한다.
> 
> 온풍기에서 바람이 한 번 나왔을 때, 온풍기의 바람이 나오는 방향에 있는 칸은 항상 온도가 5도 올라간다. 그 다음 이 바람은 계속 다른 칸으로 이동해 다른 칸의 온도를 위의 그림과 같이 상승시키게 된다. 어떤 칸 (x, y)에 온풍기 바람이 도착해 온도가 k (> 1)만큼 상승했다면, (x-1, y+1), (x, y+1), (x+1, y+1)의 온도도 k-1만큼 상승하게 된다. 이때 그 칸이 존재하지 않는다면, 바람은 이동하지 않는다. 온풍기에서 바람이 한 번 나왔을 때, 어떤 칸에 같은 온풍기에서 나온 바람이 여러 번 도착한다고 해도 온도는 여러번 상승하지 않는다.  
> 일부 칸과 칸 사이에는 벽이 있어 온풍기 바람이 지나갈 수 없다. 바람이 오른쪽으로 불었을 때 어떤 칸 (x, y)에서 (x-1, y+1)로 바람이 이동할 수 있으려면, (x, y)와 (x-1, y) 사이에 벽이 없어야 하고, (x-1, y)와 (x-1, y+1) 사이에도 벽이 없어야 한다. (x, y)에서 (x, y+1)로 바람이 이동할 수 있으려면 (x, y)와 (x, y+1) 사이에 벽이 없어야 한다. 마지막으로 (x, y)에서 (x+1, y+1)로 바람이 이동할 수 있으려면, (x, y)와 (x+1, y), (x+1, y)와 (x+1, y+1) 사이에 벽이 없어야 한다.  
> 구사과의 집에는 온풍기가 2대 이상 있을 수도 있다. 이 경우 각각의 온풍기에 의해서 상승한 온도를 모두 합한 값이 해당 칸의 상승한 온도이다.
> 
> 온도가 조절되는 과정은 다음과 같다.  
> 모든 인접한 칸에 대해서, 온도가 높은 칸에서 낮은 칸으로 ⌊(두 칸의 온도의 차이)/4⌋만큼 온도가 조절된다. 온도가 높은 칸은 이 값만큼 온도가 감소하고, 낮은 칸은 온도가 상승한다. 인접한 두 칸 사이에 벽이 있는 경우에는 온도가 조절되지 않는다. 이 과정은 모든 칸에 대해서 동시에 발생한다.  
> 모든 칸에 대해서 동시에 온도의 조절이 발생한다.
> 
> 방의 크기와 방에 설치된 온풍기의 정보, 벽의 위치와 조사하려고 하는 칸의 위치가 주어진다. 구사과가 먹은 초콜릿의 개수를 출력한다.
> 
> 첫째 줄에 세 정수 R, C, K가 주어진다. 둘째 줄부터 R개의 줄에 방의 정보가 주어진다. i번째 줄의 j번째 정수는 (i, j)의 정보를 의미하며 다음 중 하나이다.
> 
> > 0: 빈 칸  
> > 1: 방향이 오른쪽인 온풍기가 있음  
> > 2: 방향이 왼쪽인 온풍기가 있음  
> > 3: 방향이 위인 온풍기가 있음  
> > 4: 방향이 아래인 온풍기가 있음  
> > 5: 온도를 조사해야 하는 칸
> 
> 다음 줄에는 벽의 개수 W가 주어진다. 다음 W개의 줄에는 벽의 정보가 주어지며, 이 정보는 세 정수 x, y, t로 이루어져 있다. t가 0인 경우 (x, y)와 (x-1, y) 사이에 벽이 있는 것이고, 1인 경우에는 (x, y)와 (x, y+1) 사이에 벽이 있는 것이다.
> 
> 구사과가 먹는 초콜릿의 개수를 출력한다. 만약, 먹는 초콜릿의 개수가 100을 넘어가면 101을 출력한다.

### 문제 설명부터가 긴 노가다
시간경과에 따른 변화를 시뮬레이션 하는 DFS류 문제 중에서도 꽤 난이도 높은 편이었다.  
노가다랑 긴 코드가 싫어서 어떻게든 줄이려다 시간을 많이 잡아먹었다.
### 코드
```c++
#include <iostream>
#include <vector>
#include <memory.h>
using namespace std;
typedef pair<int, int> pii;
int N, M, K, W, r, c, choco;
int board[21][21];//온도 정보 저장할 배열
int visit[21][21];//방문 정보 저장할 배열
int delta[21][21];//온도 조절 편차 저장할 배열
bool wall[2][21][21];//벽 배열
vector<pair<pii, int>> opk;//온풍기 벡터
vector<pii> watchingu;//관측 지점 벡터
pii mov[5] = { {0,0}, {0,1},{0,-1},{-1,0},{1,0} };//이동용 페어 배열

void opkburst(pii pos, int dir, int cur) {//온풍기 바람 구현
    board[pos.first][pos.second] += cur;//들어온 세기만큼 온도 상승
    cur--;//세기 감소
    if (!cur) return;//세기가 0이 되면 종료
    int hv = dir - 2 <= 0;//종/횡을 구분할 변수. 0은 종방향 1은 횡방향
    int nx[3], ny[3];//다음으로 갈 좌표 배열
    nx[0] = pos.first + mov[dir].first, ny[0] = pos.second + mov[dir].second;//가운데 좌표. 그냥 이동 배열에서 더해줌
    nx[1] = nx[0] - (!(bool)mov[dir].first), ny[1] = ny[0] - (!(bool)mov[dir].second);
    nx[2] = nx[0] + (!(bool)mov[dir].first), ny[2] = ny[0] + (!(bool)mov[dir].second);
    //가운데 좌표로부터 옆의 좌표를 구할땐 이동 안한 쪽을 가감
    for (int i = 0; i < 3; i++) {//새 좌표 3개에 대해서
        if (nx[i] < 1 || ny[i] < 1 || nx[i] > N || ny[i] > M || visit[nx[i]][ny[i]]) continue;//범위를 벗어나거나 방문 이력이 있다면 넘어감
        if (!i && wall[hv][max(pos.first, nx[0])][min(pos.second, ny[0])]) continue;//가운데 좌표 진행을 막는 벽이 있으면 넘어감
        if (i && (wall[0][max(pos.first, nx[i])][hv ? pos.second : ny[i]] || wall[1][hv ? nx[i]:pos.first][min(pos.second,ny[i])])) continue;//날개 좌표 막는 벽이 있다면 넘어감
        visit[nx[i]][ny[i]] = true;//방문 체크
        opkburst({ nx[i],ny[i] }, dir, cur);//깊이 우선 탐색
    }
}

void ondozozul(int x, int y) {//온도조절
    for (int i = 1; i <= 4; i++) {//4방향에 대해
        int hv = i - 2 <= 0;//종/횡을 구분할 변수
        int nx = x + mov[i].first, ny = y + mov[i].second;//새 좌표
        if (nx < 1 || ny < 1 || nx > N || ny > M) continue;//범위를 벗어나면 넘어감
        if (wall[hv][max(x, nx)][min(y, ny)]) continue;//벽이 막으면 넘어감
        delta[x][y] += (board[nx][ny] - board[x][y]) / 4;//편차 배열에 온도 조절량 저장
    }
}

void workout() {//끝낼때까지 실행하는 
    for (int i = 0; i < opk.size(); i++) {//모든 온풍기에 대해
        pii init = opk[i].first;
        init.first += mov[opk[i].second].first;
        init.second += mov[opk[i].second].second;
        //바람 발사할 좌표 조정
        opkburst(init, opk[i].second, 5);//조정된 좌표로 바람 발사
        memset(visit, false, sizeof(visit));//바람 다 쐈으면 방문 배열을 초기화해 다음 탐색에 대응하도록 한다
    }
    for (int i = 1; i <= N; i++) for (int j = 1; j <= M; j++) ondozozul(i, j);//모든 좌표에 대해 온도 조절
    for (int i = 1; i <= N; i++) for (int j = 1; j <= M; j++) {
        board[i][j] += delta[i][j];//모든 좌표에 대해 온도 편차 더한 후
        delta[i][j] = 0;//온도 편차는 초기화
        if (i == 1 || i == N || j == 1 || j == M) board[i][j]--;//가장자리를 1도 마이너스
        board[i][j] = max(board[i][j], 0);//0도 밑으로 내려갔다면 0도로 되돌림
    }
    choco++;//초코 냠냠
    if (choco > 100) {//100을 넘어가면 101 출력하고 종료
        cout << choco;
        return;
    }
    for (int i = 0; i < watchingu.size(); i++) {//모든 관측 지점에 대해
        if (board[watchingu[i].first][watchingu[i].second] < K) {//하나라도 지정 온도가 안되면
            workout();//다시 한다
            return;//그 다음은 바로 종료
        }
    }
    cout << choco;//무사히 넘어왔다면 초코 개수를 출력
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin >> N >> M >> K;
    for (int i = 1; i <= N; i++)for (int j = 1; j <= M; j++) {//좌표에 대해 값 받아줌
        cin >> board[i][j];
        if (board[i][j]) {//입력이 0이 아니라면
            if (board[i][j] == 5)watchingu.push_back({ i,j });//5 일 땐 관측 지점 벡터에 좌표를 넣어줌
            else opk.push_back({ {i,j},board[i][j] });//1 ~ 4 일 땐 온풍기 벡터에 좌표와 종류를 넣어줌 
            board[i][j] = 0;//온도 용으로 쓸 거니까 0으로 변경
        }
    }
    cin >> W;
    while (W--) {
        int a;
        cin >> r >> c >> a;
        wall[a][r][c] = true;
        //벽 정보 입력
    }
    workout();//될 때 까지 
}
```
### 여담
따로 hv 변수랑 수학 식들 이용해서 코드 길이를 줄여보려 했지만, 만든 내용이 많다 보니 헷갈렸다.  
그래도 복잡한 수학적/CS적 개념은 안 들어가서 끈기만 있으면 할만한 듯.
