---
title: 백준 22353번 헤이카카오
layout: post
tags: [cpp]
---
### 문제 개요
> 첫 번째 줄에는 세 개의 정수 a, d, k가 공백으로 구분되어 주어진다.(1 ≤ a, d ,k ≤ 100)  
> 이는 끝말잇기 한 판에 a분이 걸리며 집중을 시작한 이하가 처음에 끝말잇기에서 이길 확률이 d%이고 패배할 때마다 승률이 이전에 비해 k%만큼 오름을 의미한다.  
> 입력으로 주어지는 값은 모두 정수이다.
> 이하가 이길 때까지 끝말잇기를 진행하는 시간의 기댓값을 분 단위로 출력한다. 절대오차 또는 상대오차가 10^(-6) 이하면 정답으로 인정된다.

### 진짜 별거 없었다
난이도 분류 치고는 그냥 대충 하니까 풀린 문제.  
일전에 자료구조까지 가야 하는 일본어 문제 도전하느라 이것저것 해본 경험 때문인지 이건 그냥 20분도 안 되어서 1트에 바로 정답.
### 코드
```c++
#include <iostream>

using namespace std;

int main()
{
	double N, M, O, ans, prob, prev, win, con;
	int cnt = 0;
	cin >> N >> M >> O;
  /*변수 선언 및 입력부*/
	win = prob = M / 100;//초기 승리 및 경우의수 확률 조정
	ans = 0;//답 초기화
	prev = 1;//이전 확률

	while (win < 1) {//승률이 100%을 넘길때까지
		con = prob;//구조상 prob값을 끝에 가져가야 하는데 중간에 연산해서 값이 바뀌는 관계상 변수 하나를 더 넣음
		ans += ++cnt * N * prob;//cnt = 전체 시도 횟수, N = 단위 시간, prob = 해당 케이스의 확률을 곱한 값을 답(기댓값)에 더해줌
		win += win * O / 100 ;//승률 상승 조정
		if (win > 1) win = 1;//승률이 100% 이상이면 100%로 조정
		prob = (prev - prob) * win;//다음 케이스 확률 조정
		prev -= con;//이전 케이스 확률 조정
	}
	ans += ++cnt * N * prob;//승률이 100%가 되어도 1번은 더 기댓값에 더해야 함
	cout.setf(ios::fixed);
	cout.precision(7);
  /*소숫점 자릿수 7자리 조정*/
	cout << ans;
}
```
### 해설
일단 기댓값의 개념을 알고 있냐가 문제다. 어차피 고등학교 과정이라 다 알거다.  
그 다음은 승률이 100% 이상이 될 때까지 반복하는 while문을 세우고, 기댓값 연산과 확률 조정을 행한다.
while문이 끝나면 1번만 더 기댓값 연산을 하고, 답을 출력하게 했다.

### 여담
한번에 풀어버려서 여담이랄 것 조차 없다.  
그냥 내가 생각한게 한번에 맞아떨어져서 놀라움.  
다만 굳이 변수를 저렇게 많이 안 써도 되지 않았나 싶기도 하다. 
