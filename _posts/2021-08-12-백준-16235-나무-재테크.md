---
title: 백준 16235 나무 재테크
layout: post
tags: [cpp]
---
### 문제 개요
> 나무 재테크란 작은 묘목을 구매해 어느정도 키운 후 팔아서 수익을 얻는 재테크이다.  
> 상도는 나무 재테크로 더 큰 돈을 벌기 위해 M개의 나무를 구매해 땅에 심었다. 같은 1×1 크기의 칸에 여러 개의 나무가 심어져 있을 수도 있다.  
> 이 나무는 사계절을 보내며, 아래와 같은 과정을 반복한다. 
>  
> 봄에는 나무가 자신의 나이만큼 양분을 먹고, 나이가 1 증가한다. 각각의 나무는 나무가 있는 1×1 크기의 칸에 있는 양분만 먹을 수 있다. 하나의 칸에 여러 개의 나무가 있다면, 나이가 어린 나무부터 양분을 먹는다. 만약, 땅에 양분이 부족해 자신의 나이만큼 양분을 먹을 수 없는 나무는 양분을 먹지 못하고 즉시 죽는다.  
> 여름에는 봄에 죽은 나무가 양분으로 변하게 된다. 각각의 죽은 나무마다 나이를 2로 나눈 값이 나무가 있던 칸에 양분으로 추가된다. 소수점 아래는 버린다.  
> 가을에는 나무가 번식한다. 번식하는 나무는 나이가 5의 배수이어야 하며, 인접한 8개의 칸에 나이가 1인 나무가 생긴다. 어떤 칸 (r, c)와 인접한 칸은 (r-1, c-1), (r-1, c), (r-1, c+1), (r, c-1), (r, c+1), (r+1, c-1), (r+1, c), (r+1, c+1) 이다. 상도의 땅을 벗어나는 칸에는 나무가 생기지 않는다.  
> 겨울에는 S2D2가 땅을 돌아다니면서 땅에 양분을 추가한다. 각 칸에 추가되는 양분의 양은 A[r][c]이고, 입력으로 주어진다. 
> K년이 지난 후 상도의 땅에 살아있는 나무의 개수를 구하는 프로그램을 작성하시오.  
>
>  첫째 줄에 N, M, K가 주어진다.  
>  둘째 줄부터 N개의 줄에 A배열의 값이 주어진다. r번째 줄의 c번째 값은 A[r][c]이다.  
>  다음 M개의 줄에는 상도가 심은 나무의 정보를 나타내는 세 정수 x, y, z가 주어진다. 처음 두 개의 정수는 나무의 위치 (x, y)를 의미하고, 마지막 정수는 그 나무의 나이를 의미한다.
>  첫째 줄에 K년이 지난 후 살아남은 나무의 수를 출력한다.

### 시간제한 빡센 문제
해봤자 실버급 정도만 풀다 골드급 찍먹 해본다고 푼 문제다.  
알고리즘 구상 자체는 금방 했고 출력이 맞게 되는 코드는 금방 짰지만, 최적화를 하는데 시간을 잔뜩 잡아먹었다.
### 코드
```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main()
{
	cin.tie(NULL); cout.tie(NULL);
	ios::sync_with_stdio(false);
	int N, M, K, ans = 0;
  int field[11][11] = { 0, }, nourish[11][11] = { 0, }, dead[11][11] = { 0, };
  //field = 각 땅 양분 정보, nourish = 겨울에 뿌리는 양분 정보, dead = 죽어서 생긴 양분 정보
	int newtreer[8] = { 0,0,1,1,1,-1,-1,-1 };
	int newtreec[8] = { 1,-1,0,1,-1,0,1,-1 };
  //새 나무 심기용 좌표 조정 배열
	vector<int> tree[11][11];
  //나무 정보
	cin >> N >> M >> K;

	for (int i = 1; i <= N; i++) {
		for (int j = 1; j <= N; j++) {
			cin >> nourish[i][j];
			field[i][j] = 5;
		}
	}
	for (int i = 0; i < M; i++) { int t1, t2, t3;  cin >> t1 >> t2 >> t3; tree[t1][t2].push_back(t3); ans++; }//나무 정보 넣으면서 나무 총 개수 카운트
  //입력부
	for (int y = 0; y < K; y++) {//K년동안 반복
		for (int i = 1; i <= N; i++) {//초기 세팅
			for (int j = 1; j <= N; j++) {
				sort(tree[i][j].begin(), tree[i][j].end());//각 땅의 나무 정렬해서 어린 나무가 앞에 오게 함
				field[i][j] += dead[i][j];//죽은 나무 양분 더하기
				dead[i][j] = 0;//양분 초기화
			}
		}
        for (int i = 1; i <= N; i++) {//봄, 여흠
            for (int j = 1; j <= N; j++) {
                for (int k = 0; k < (int)tree[i][j].size(); k++) {
                    if (field[i][j] >= tree[i][j][k]) {//양분이 나이 이상으로 있으면
                        field[i][j] -= tree[i][j][k];//양분 냠냠
                        tree[i][j][k] += 1;//나이 증가
                    }
                    else {//아닐 경우
                        int idx = k;
                        int size = (int)tree[i][j].size();
                        for (int l = size - 1; l >= idx; l--) {//어차피 그 뒤에 있는 나무들은 무조건 k살 이상이라 양분 못 먹고 죽으니 빠른 처리
                            dead[i][j] += (tree[i][j][l] / 2);//반복문을 통해 뒤에서 빼주면서 죽은 나무 양분 정보에 더하기
                            tree[i][j].pop_back();
                            ans--;//나무 개수 빼기
                        }
                        break;//사실 저 반복문 돌게 되면뒤로 더 갈 필요 없이 처리가 되므로 여기서 break
                    }
                }
            }
        }
        for (int i = 1; i <= N; i++) {//가을
            for (int j = 1; j <= N; j++) {
                for (int s = 0; s < tree[i][j].size(); s++) {
                    int age = tree[i][j][s];
                    if (age % 5 != 0) continue;//나무 나이가 5의 배수 아니면 스킵
                    for (int k = 0; k < 8; k++) {
                        int nr = i + newtreer[k];
                        int nc = j + newtreec[k];
                        //새 나무 좌표
                        if (nr > N || nr < 1 || nc > N || nc < 1) continue;//불가능한 좌표면 스킵
                        tree[nr][nc].push_back(1);//새 나무 심기
                        ans++;//나무 개수 더하기
                    }
                }
            }
        }
		if (y == K - 1) {//마지막 년도면
			cout << ans;
			return 0;
      //답 출력하고 겨울 생략
		}
		for (int fi = 1; fi <= N; fi++) for (int fj = 1; fj <= N; fj++) field[fi][fj] += nourish[fi][fj];//겨울. 영양분 더하기
	}
}
```
### 해설
구현 자체는 어렵지 않았는데, 최적화가 힘들었다.  
일단 나무 정보는 벡터로 받아서 입출력 하면서 개수가 조정이 되어야 편할테고, 나머지 배열들은 어차피 최대값이 작으니 인덱스를 활용할 수 있는 크기로 선언.  
배열을 이용해 새 나무의 행, 열 좌표 이동값을 설정하고 각 연도에 대해 반복문을 세웠다.  
이 때 빠른 처리를 위해 봄/여름은 합치고 답도 시간복잡도를 줄이려 중간에 처리하게 했다.
### 여담
처음엔 전부 벡터로 해서 깔끔한 배열크기 하려다 실패.  
그리고 가독성을 위해 봄/여름/가을/겨울 다 나눠서 반복문에 집어넣다 시간 초과하길 반복했다.  
그러다 최적화 관련해서 적당히 검색해서 찾아보고 적용시킨게 저것.  
진짜 시간제한 빡세다.
