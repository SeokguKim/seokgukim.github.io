---
title: 백준 9019번 DSLR
layout: post
tags: [cpp]
---
### 문제 개요
> 네 개의 명령어 D, S, L, R 을 이용하는 간단한 계산기가 있다. 이 계산기에는 레지스터가 하나 있는데, 이 레지스터에는 0 이상 10,000 미만의 십진수를 저장할 수 있다. 각 명령어는 이 레지스터에 저장된 n을 다음과 같이 변환한다. n의 네 자릿수를 d1, d2, d3, d4라고 하자(즉 n = ((d1 × 10 + d2) × 10 + d3) × 10 + d4라고 하자)
> 1. D: D 는 n을 두 배로 바꾼다. 결과 값이 9999 보다 큰 경우에는 10000 으로 나눈 나머지를 취한다. 그 결과 값(2n mod 10000)을 레지스터에 저장한다
> 2. S: S 는 n에서 1 을 뺀 결과 n-1을 레지스터에 저장한다. n이 0 이라면 9999 가 대신 레지스터에 저장된다.
> 3. L: L 은 n의 각 자릿수를 왼편으로 회전시켜 그 결과를 레지스터에 저장한다. 이 연산이 끝나면 레지스터에 저장된 네 자릿수는 왼편부터 d2, d3, d4, d1이 된다.
> 4. R: R 은 n의 각 자릿수를 오른편으로 회전시켜 그 결과를 레지스터에 저장한다. 이 연산이 끝나면 레지스터에 저장된 네 자릿수는 왼편부터 d4, d1, d2, d3이 된다.
> 위에서 언급한 것처럼, L 과 R 명령어는 십진 자릿수를 가정하고 연산을 수행한다. 예를 들어서 n = 1234 라면 여기에 L 을 적용하면 2341 이 되고 R 을 적용하면 4123 이 된다.
> 여러분이 작성할 프로그램은 주어진 서로 다른 두 정수 A와 B(A ≠ B)에 대하여 A를 B로 바꾸는 최소한의 명령어를 생성하는 프로그램이다. 예를 들어서 A = 1234, B = 3412 라면 다음과 같이 두 개의 명령어를 적용하면 A를 B로 변환할 수 있다.
> 
> 1234 →L 2341 →L 3412  
> 1234 →R 4123 →R 3412
> 
> 따라서 여러분의 프로그램은 이 경우에 LL 이나 RR 을 출력해야 한다.
> n의 자릿수로 0 이 포함된 경우에 주의해야 한다. 예를 들어서 1000 에 L 을 적용하면 0001 이 되므로 결과는 1 이 된다. 그러나 R 을 적용하면 0100 이 되므로 결과는 100 이 된다.
> 
> 프로그램 입력은 T 개의 테스트 케이스로 구성된다. 테스트 케이스 개수 T 는 입력의 첫 줄에 주어진다. 각 테스트 케이스로는 두 개의 정수 A와 B(A ≠ B)가 공백으로 분리되어 차례로 주어지는데 A는 레지스터의 초기 값을 나타내고 B는 최종 값을 나타낸다. A 와 B는 모두 0 이상 10,000 미만이다.
> 
> A에서 B로 변환하기 위해 필요한 최소한의 명령어 나열을 출력한다. 가능한 명령어 나열이 여러가지면, 아무거나 출력한다.

### 너비 우선 탐색
최소한의 명령어를 구해야 하니 너비 우선 탐색으로 같은 길이의 문자열을 우선으로 함수를 순회시키면서 일치여부를 판단하도록 큐를 구현하면 된다.
### 코드
```c++
#include <iostream>
#include <queue>

using namespace std;

int opD(int num) {//D 연산자
    return num * 2 % 10000;//2배하고 10000으로 나눔
}
int opS(int num) {//S연산자
    if (num)return num - 1;//0이 아니면 1 빼고
    else return 9999;//0이면 9999
}
int opL(int num) {//L연산자
    return (num % 1000) * 10 + num / 1000;//자리이동
}
int opR(int num) {//R연산자
    return (num % 10) * 1000 + num / 10;//자리이동
}
int (*fp[4])(int) = { opD,opS,opL,opR };//호출을 편하게 하기 위해 포인터 배열을 선언
int N, aa, bb;//입력받을 변수들
string op[4] = { "D","S","L","R" };//문자열 추가를 위한 문자 배열

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    //입출력 구문
    cin >> N;//테스트 케이스 횟수 입력
    while (N--) {//N회동안
        cin >> aa >> bb;//입력을 받고
        queue<pair<int,string>> q;//빈 큐를 선언
        q.push({ aa,"" });//기본 숫자와 빈 문자열을 넣음
        bool visit[10000] = { false, };//반복실행을 없애기 위해 방문여부를 체크
        visit[aa] = 1;//일단 기본 숫자는 방문한 걸로 처리
        while (!q.empty()) {//큐가 빌때까지(어차피 중간에 끊고 나올거지만)
            int cn = q.front().first;//큐 맨 앞의 첫 원소를 cn으로
            string cum = q.front().second;//두번째를 cum으로
            q.pop();//큐 맨 앞 제거
            if (cn == bb) {//대상 숫자와 일치하면
                cout << cum << "\n";//현재까지의 연산 출력
                break;//이 테스트 케이스는 종료
            }
            for (int i = 0; i < 4; i++) {//반복자 선언
                int nn = fp[i](cn);//원본 숫자에 대해 각 연산을 진행
                if (!visit[nn]) {//결과 숫자를 방문한적 없으면
                    visit[nn] = 1;//방문표시
                    q.push({ nn, cum + op[i] });//큐에 넣음
                }
            }
        }
    }
}
```
### 해설
큐로 구현하면 되는 흔한 너비 탐색 문제다.  
큐에 기본 숫자를 넣고, 큐에서 원소를 하나씩 꺼내면서 목표 숫자와 대조한다.  
만약 일치하지 않는다면 각 연산의 결과에 대한 방문 여부를 대조해 방문하지 않았다면 연산이력과 함께 다시 큐에 넣는다. 
다행히도 연산 결과만 일치하고 같은 횟수의 연산이라면 아무거나 출력해도 괜찮았다.
### 여담
뭔가 시간이 되게 오래 걸리길래 이상하다 했지만 맞았다. 이런 문제도 있구만.
