---
title: 백준 22971번 증가하는 부분 수열의 개수
layout: post
tags: [cpp]
---
### 문제 개요
> 길이가 N인 수열 A가 주어진다. 수열의 i번째 원소A(i)로 끝나는 증가하는 부분 수열의 개수를 출력하는 프로그램을 작성하자.
> 
> 단, 수가 너무 커질 수 있으니 998,244,353으로 나눈 나머지를 출력한다.
>
> 첫째 줄에 수열의 길이 N이 주어진다.
> 둘째 줄에 N개의 정수 A1, A2, ..., AN이 공백으로 구분되어 주어진다.
>
> 첫 번째 줄에 N개의 정수를 출력한다.
> i번째로 출력하는 수는 A(i)로 끝나는 증가하는 부분 수열의 개수를 998,244,353로 나눈 값이다.

### 간단하지만 자료형에 주의
문제 자체는 간단하나 중간에 오버플로우할 건덕지가 있어 조정을 잘 해줘야 한다.  
그것만 빼면 별거 없다.
### 코드
```c++
#include <iostream>

using namespace std;

int N, Nums[5000];//입력
long long Data[5000];//개수 저장 배열 Data[i]는 i + 1번째로 끝나는 증가 부분 수열 개수

int main()
{
	cin.tie(NULL); cout.tie(NULL);
	ios::sync_with_stdio(false);
	
	cin >> N;

	for (int i = 0; i < N; i++) cin >> Nums[i];
  //입력부
	for (int i = 0; i < N; i++) {
		Data[i] = 1;//개수 초기값 1
		for (int j = i; j > 0; j--) {//해당 인덱스로부터 하나씩 내려가면서
			if (Nums[j - 1] < Nums[i]) {//i보다 j - 1이 작은지 여부 확인  
				Data[i] += Data[j - 1];//작은 경우 수열에 포함시킬 수 있으므로, Data[j - 1]만큼을 Data[i]에 더해준다.
				Data[i] %= 998244353;//오버플로우 나지 않게 모든 중간 계산값을 지정 숫자로 나눠야 함.
			}
		}
		cout << Data[i] << " ";
	}
}
```
### 해설
말을 어렵게 해놓으니 알아먹기 귀찮지만, 사실상 한 수열의 특정 원소에 대해 그 앞에 있는 원소가 해당 원소보다 작을 경우,  
앞의 원소로 만들 수 있는 모든 증가 부분 수열을 포함시키는 식으로 계산하라는 거다.  

**즉, 대충 조건부 덧셈 문제란 소리.**

중간에 값이 커지면 오버플로우가 나는걸 방지하기 위해 998,244,353으로 나누라고 그렇게 강조했다. 잘 나눠주자.
### 여담
처음에 구조가 갈피가 안 잡힐때 재귀함수로 풀려다 실패했다.  
요새 재귀함수 만능론에 빠진듯.
