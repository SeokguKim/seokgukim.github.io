---
title: 백준 21559번 암호 찾기
layout: post
tags: [cpp]
---
### 문제 개요
> 오랜 기간 동안 세계 4대 문명이 최초의 문명으로 알려져 있었으나, 얼마 전 이를 뒤집는 고고학적 연구 결과가 발표되었습니다. 이번에 새로 발견된 문명인 ‘폴리매스 문명’은 기원전 9000년경부터 존재하였음이 확인되었습니다.  
> 당신은 고고학자로, 폴리매스 문명을 연구하는 임무를 맡고 있습니다. 폴리매스 문명은 보안을 위해 특이한 형식의 비밀번호를 사용하였는데, 이에 대한 자세한 설명은 아래와 같습니다.  
> 사람들은 비밀번호의 규칙과 관련된 두 개의 숫자들로 이루어진 문자열을 만들었습니다. 이 두 문자열 $A$와 $B$의 길이는 각각 $N$으로 같습니다. 이 중 $A$와 $B$ 모두의 부분 문자열이면서, 길이가 정확히 $K$인 것이 비밀번호가 됩니다.  
> 비밀번호가 여러 개이거나 하나도 없을 수도 있는데, 이런 경우 $A$와 $B$가 기록이 잘못된 것입니다. 기록이 올바른지 판정하기 위해, 가능한 서로 다른 비밀번호의 수를 구하는 프로그램을 작성해 봅시다.
> 
> 첫 줄에는 각 문자열의 길이 $N$과 뽑아낼 수의 자릿수 $K$가 주어집니다. 둘째 줄에는 문자열 $A$가 주어집니다. 셋째 줄에는 문자열 $B$가 주어집니다.
> 
> $A$와 $B$ 모두의 부분문자열이고 길이가 $K$인 서로 다른 문자열의 수를 출력합니다.

### 속도랑 메모리 둘 다로 괴롭힌다
kmp로 풀려고 하면 시간이, 단순히 map/set을 쓰려고 하면 메모리가 문제가 된다.  
적당히 잘 해싱해줘야 해서 베이스 값이랑 모듈러 값 조정하느라 트라이를 많이 한 문제.
### 코드
```c++
#include <iostream>
#include <set>
using namespace std;
typedef long long ll;
#define MOD 1e15 + 7//모듈러 값은 충분히 큰 소수 
string s;
int N, M, cnt;
set<ll> ss;
ll base = 31, mod = MOD;//베이스 값은 영문자를 커버할 정도의 31, 모듈러값도 정의

ll rabin_hash(string s) {//해시 함수
	ll ans = 0;//0에서 시작
	for (char ch : s) {//주어진 문자열에 대해
		ans = (ans * base + ch) % mod;//해시 실행하고 모듈러 값으로 나눠줌
	}
	return ans;
}
void rabin_karp(string s, bool inorout) {//비슷한 작업이지만 첫번째와 두번째를 구분짓기 위해 inorout 변수를 사용
	int n = s.length();
	ll hash_s = rabin_hash(s.substr(0, M));//처음으로부터 길이 M만큼의 문자열에 대해 해시
	ll first = 1;//라빈-카프 하면서 첫 문자의 값에 곱해줄 배수

	for (int i = 0; i < M - 1; i++)
		first = (first * base) % mod;//배수 설정

	for (int i = 0; i <= n - M; i++) {//모든 가능한 부분 문자열에 대해
		if (inorout) ss.insert(hash_s);//첫 번째 문자열에서 삽입할땐 해시값을 그냥 set에 삽입
    else {//두번째 문자열로 검색할때
        if (ss.find(hash_s) != ss.end()) {//해당 문자열의 해시값을 찾았다면 
           ss.erase(hash_s);//셋에서 지우고
	         cnt++;//카운트
	      }
    }
		if (i + M < n) {//진행할 부분 문자열이 남아있다면
			hash_s = hash_s - (s[i] * first) % mod;//첫 문자에 배수를 곱한 값을 빼줌
			hash_s = (hash_s + mod) % mod;//음수일수도 있으니 양수로
			hash_s = ((hash_s * base) % mod + s[i + M]) % mod;//배수만큼 곱하고 신규 문자 값을 더해 진행
		}
	}
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	
	cin >> N >> M >> s;//첫 문자열까지 입력받고
	rabin_karp(s, 1);//삽입 부분 실행
	cin >> s;//두번째 문자열 입력받고
	rabin_karp(s, 0);//검색 부분 실행
	cout << cnt;
}
```
### 여담
그냥 해시 계열 컨테이너에 string 그대로 넣으려 하면 메모리 초과가 될 정도로 극단적인 데이터가 들어있어  
일단 long long으로 해싱한 값을 충돌하질 않길 기도하면서 넣어야 했다.  
역시 프로그래밍은 신앙의 영역이다.
