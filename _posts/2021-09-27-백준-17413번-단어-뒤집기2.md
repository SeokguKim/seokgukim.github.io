---
title: 백준 17213번 단어 뒤집기2
layout: post
tags: [cpp]
---
### 문제 개요
> 문자열 S가 주어졌을 때, 이 문자열에서 단어만 뒤집으려고 한다.  
> 
> 먼저, 문자열 S는 아래와과 같은 규칙을 지킨다.  
> 
> 알파벳 소문자('a'-'z'), 숫자('0'-'9'), 공백(' '), 특수 문자('<', '>')로만 이루어져 있다. 
> 문자열의 시작과 끝은 공백이 아니다.
> '<'와 '>'가 문자열에 있는 경우 번갈아가면서 등장하며, '<'이 먼저 등장한다. 또, 두 문자의 개수는 같다.
> 태그는 '<'로 시작해서 '>'로 끝나는 길이가 3 이상인 부분 문자열이고, '<'와 '>' 사이에는 알파벳 소문자와 공백만 있다. 단어는 알파벳 소문자와 숫자로 이루어진 부분 문자열이고, 연속하는 두 단어는 공백 하나로 구분한다. 태그는 단어가 아니며, 태그와 단어 사이에는 공백이 없다.  
> 
> 첫째 줄에 문자열 S가 주어진다. S의 길이는 100,000 이하이다.  
> 
> 첫째 줄에 문자열 S의 단어를 뒤집어서 출력한다.

### 판별만 잘 하면 된다
판별 과정이 좀 복잡하게 돌아가서 그렇지, 문자열 전체를 입력받은 다음 각 문자에 대해 연산해서 결과를 출력하면 되는 문제다.  
reverse 함수가 algorithm에 있어서 다행.
### 코드
```c++
#include <iostream>
#include <algorithm>

using namespace std;

int main() {

    ios::sync_with_stdio(false);
    cin.tie(NULL);cout.tie(NULL);
    
    string s, ns, ts; bool istag = false;//s에 입력, ns에 출력할 문자열 저장. ts는 뒤집어야 할 단어를 나타내는 임시 문자열. 태그인지를 구분하기 위한 istag.
    getline(cin, s);//개행문자 전까지 입력받음
    int sl = s.length();//문자열의 길이를 미리 받아놓는데, 이는 for 문의 제약식으로 걸 때 길이를 기준으로 걸면 돌 때마다 길이를 재연산해서 시간을 더 먹기 때문.

    for (int i = 0; i < sl; i++) {//입력받은 문자열의 각 문자에 대해
        if (s[i] == '<') {//'<'를 입력받으면
            if (ts.size()) {//만약 저장된 단어가 있으면
                reverse(ts.begin(), ts.end());//뒤집고
                ns += ts;//문자열에 추가
                ts.clear();//단어 초기화
            }
            istag = true;//이후는 태그로 처리
        }
        if (istag) {//태그 입력이라면
            ns += s[i];//해당 문자는 그대로 새 문자열에 추가해줌
            if (s[i] == '>') istag = false;//만약 '>'라면 다음부턴 태그가 아니니 istag를 false로
            continue;//처리 끝나면 다음 연산은 씹고 컨티뉴
        }
        if (s[i] == ' ') {//공백이면
            if (ts.size()) {//저장된 단어가 있으면
                reverse(ts.begin(), ts.end());//뒤집고
                ns += ts;//문자열에 추가
                ts.clear();//단어 초기화
            }
            ns += " ";//공백 더해줌
            continue;//연산 끝났으면 컨티뉴
        }
        ts += s[i];//컨티뉴문에 안 걸렸을 경우, 태그가 아닌 상태의 공백이 아닌 문자라는 뜻이므로 일단 새 단어에 1자씩 더해준다.
        if (i == sl - 1 && ts.size()){//문자열 끝에 도달했을때, 단어가 있다면
            reverse(ts.begin(), ts.end());//뒤집고
            ns += ts;//추가함
        }
    }
    cout << ns;//새 단어 출력
}
```
### 해설
일단 getline 함수로 전체 문장을 한번에 입력받은 다음, 각 문자에 대해 새 문자열에 그대로 넣을지, 단어를 구성해 뒤집을지를 판별했다.  
'<' 나 ' '가 오면 단어의 끝을 나타내게 되므로 단어를 추가하는 연산을 해주고 각각에 대해 태크인지를 판별하는 연산을 진행해 둬서 태그가 아닌 것들만  
단어에 일단 추가된 후 뒤집히게 했다.  
### 여담
코드 짜다 보니 if문 분기를 너무 많이 넣어서 길어진 느낌이다.  
좀 더 간단한 것도 생각을 해봐야겠다.
