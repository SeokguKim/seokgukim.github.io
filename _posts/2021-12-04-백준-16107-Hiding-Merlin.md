---
title: 백준 16107번 Hiding Merlin
layout: post
tags: [cpp]
---
### 문제 개요
> The war is coming to an end. King Arthur and his loyal servants have grouped together to eradicate Mordred and his minions. If all goes well, the war will be over by tomorrow. The only thing that now worries King Arthur is the news that an assassin is out to get Merlin.  
> King Arthur has decided to hide Merlin in one of the billion houses in Camlann. The houses in Camlann are numbered 1, 2, . . . , 999 999 999, 1 000 000 000. Because King Arthur does not want to forget which house he has hid Merlin in, he would like to write it down. However, King Arthur is worried about security, so he is going to encrypt the house number. But since this is the fifth century AD, the encryption that he will use is quite primitive. He first writes the number down as a sum of positive square numbers, then concatenates those squares together and writes down that string.  
> For example, if the house number is 46, then he could write down 3691 since 46 = 36 + 9+ 1 = 62 + 32 + 12. King Arthur could also write down 1369 (46 = 1 + 36 + 9) or 1619416 (46 = 16 + 1 + 9 + 4 + 16). King Arthur writes each of the squares with no leading zeroes.  
> What is the smallest house number in Camlann that is consistent with the encrypted house number that King Arthur wrote down?
> 
> The input consists of a single line containing a string, which is the encrypted house number. The encrypted house number contains only digits (0, 1, . . . , 9) and has length at least 1 and at most 100 000.
> 
> Display the smallest house number in Camlann that is consistent with the encrypted house number. If the encrypted house number could not have been obtained by King Arthur’s encryption scheme, display -1 instead.

### 다이나믹 프로그래밍
일단 케이스가 너무 많이 나오는 문제다. 다이나믹 프로그램으로 연산횟수를 줄여야 시간제한에 맞겠다.
### 코드
```c++
#include <iostream>
#include <math.h>//제곱수 판별을 위한 sqrt 함수를 쓰기 위해 사용
#define INF 1000000001//최대값이 1,000,000,000이므로 이렇게 설정
using namespace std;

string amho;//암호를 받을 문자열
int len;//암호의 길이
long long dap[100000];//해당 지점으로부터의 가능한 복호 결과를 저장할 배열
bool issquare(long long num) {//제곱수 판별
    long long temp;
    switch (num & 0x0f) {//16진수 비트연산으로 16으로 나눈 나머지를 판별
    case 0:
    case 1:
    case 4:
    case 9:
        temp = (long long)(sqrt((double)num) + 0.5);
        return temp * temp == num;
    //0,1,4,9 라면 제곱수일 가능성이 있으므로 검증
    default:
        return false;
    //아니면 검증 필요 없이 false
    }
}

long long decoder(int idx) {//해독기
    if (idx == len) return 0;//인덱스가 문자열 길이와 같으면 모든 문자열 끝까지 탐색이 끝났으므로 0을 반환
    if (dap[idx]) return dap[idx];//이미 연산결과가 있다면 그걸 반환
    long long a = 0, b;//암호 해독에 쓰일 long long형 변수 두개
    dap[idx] = INF;
    for (int i = idx; i < len; i++) {//가능한 모든 경우 탐색
        b = amho[i] - 48;//문자열의 문자 하나를 읽어와서 정수로 변환
        a = a * 10 + b;//이전 문자열에 합산
        if (a >= INF || !a) break;//a가 INF 이상이거나, 0이라면 연산이 무의미하므로 제회
        if (issquare(a)) dap[idx] = min(dap[idx], a + decoder(i + 1));//제곱수라면 현재의 복호화 결과 최솟값과 재귀로 구한 최솟값을 비교해 작은 쪽을 저장
    }
    return dap[idx];//저장된 복호화 결과를 리턴
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> amho;//입력받고
    len = amho.length();//,len = 암호의 길이
    long long aa = decoder(0);//함수를 돌려서
    if (aa == INF) cout << -1;//결과가 INF라면 -1을 출력하고
    else cout << aa;//아니면 그 결과값을 출력
}
```
### 해설
제곱수를 빨리 구하는 방법부터, 내재된 건너뛰기 조건까지 생각할게 많다.  
잘 생각해보면 0으로 시작하는 지점에서는 연산을 건너뛰어도 되며, 제곱수를 구할 방법도 여러가지다.  
다이나믹하게 잘 해보자.
### 여담
며칠째 못 풀어서 끙끙 앓던 문제. 아무리 검색해도 레퍼런스가 없었다.   
결국 혼자 힘으로 풀어버렸다. 왜 아무도 안 도와줘...
