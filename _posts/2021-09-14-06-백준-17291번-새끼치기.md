---
title: 백준 17291번 새끼치기
layout: post
tags: [cpp]
---
### 문제 개요
> 실험실에서 새로운 종의 벌레 한 마리가 탄생하였다. 벌레는 스스로 분열하며, 분열하면 자기 자신과 같은 벌레를 한 마리 만들어 내게 된다. 벌레가 분열하는 규칙은 다음과 같다.
> 벌레는 기준년도 1년 2월에 1마리가 탄생한다.
> 벌레는 매년 1월이 되면 분열한다. 분열시 본래의 개체는 그대로, 새로운 개체가 하나 탄생하는 것으로 본다.
> 홀수년도에 탄생한 개체는 3번 분열시, 짝수년도에 탄생한 개체는 4번 분열시 사망한다.
> 예를 들어, 기준년도 1년 2월에 존재하던 벌레는, 2년 1월, 3년 1월, 4년 1월에 분열하고 사망하여 4년 말에는 존재하지 않게 된다. 이 때, N년 말에 존재하는 벌레의 수를 구하여라.
> 
> 첫째 줄에 자연수 N(1 ≤ N ≤ 20)이 주어진다.
> 
> 첫째 줄에 N년 말에 존재하는 벌레의 수를 출력한다.

### 그냥 대충 벡터 가지고 놀았더니 됐음
그냥 벡터에 남은 수명 집어넣고 0이 되면 빼고만 반복하는 단순한 코드로 됐다. 생각보다 별거 없다.
### 코드
```c++
#include <iostream>
#include <vector>	

using namespace std;

int N;//벌레수 구할 연도
vector<int> bugs;//벌레 남은 수명 저장할 벡터

int main()
{
	cin.tie(NULL); cout.tie(NULL);
	ios::sync_with_stdio(false);

	cin >> N;
	bugs.push_back(3);//초기 1년도
	for (int i = 2; i <= N; i++) {//2년도부터
		int bs = bugs.size();//새 벌레는 제외하고 기존 벌레들에 대해서만 연산할거라 분열 전 사이즈를 변수로 받음
		if (i % 2 == 0) for (int j = 0; j < bs; j++) {//짝수년도일때 기존 벌레에 대해
			bugs[j]--; bugs.push_back(4);//수명 감소시키고 1마리 늘림(분열)
            if (bugs[j] == 0) {//해당 개체 수명이 0이 되면
				bugs.erase(bugs.begin() + j); j--; bs--;//지우고 인자값 조정
			}
		}
		else for (int j = 0; j < bs; j++) {//홀수년도일때 기존 벌레에 대해
			bugs[j]--; bugs.push_back(3);//수명 감소시키고 1마리 늘림(분열)
            if (bugs[j] == 0) {//해당 개체 수명이 0이 되면
				bugs.erase(bugs.begin() + j); j--; bs--;//지우고 인자값 조정
			}
		}
	}
	cout << bugs.size();
}
```
### 해설
벡터에 일단 초기값으로 3을 넣은 후, 짝수/홀수 연도에 맞춰 분열할 때마다 여명을 감소시키고 신생개체를 추가하는 식으로 했다.  
그냥 했는데 됐음.
### 여담
처리시간이 400ms, 메모리가 3600kb 정도로 꽤나 많은 자원을 잡아먹는 코드였다.  
다음번엔 처리 단순화도 궁리를 좀 해봐야겠다.
