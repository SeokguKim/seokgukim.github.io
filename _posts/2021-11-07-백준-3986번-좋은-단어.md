---
title: 백준 3986번 좋은 단어
layout: post
tags: [cpp]
---
### 문제 개요
> 이번 계절학기에 심리학 개론을 수강 중인 평석이는 오늘 자정까지 보고서를 제출해야 한다. 보고서 작성이 너무 지루했던 평석이는 노트북에 엎드려서 꾸벅꾸벅 졸다가 제출 마감 1시간 전에 깨고 말았다. 안타깝게도 자는 동안 키보드가 잘못 눌려서 보고서의 모든 글자가 A와 B로 바뀌어 버렸다! 그래서 평석이는 보고서 작성을 때려치우고 보고서에서 '좋은 단어'나 세보기로 마음 먹었다.
> 평석이는 단어 위로 아치형 곡선을 그어 같은 글자끼리(A는 A끼리, B는 B끼리) 쌍을 짓기로 하였다. 만약 선끼리 교차하지 않으면서 각 글자를 정확히 한 개의 다른 위치에 있는 같은 글자와 짝 지을수 있다면, 그 단어는 '좋은 단어'이다. 평석이가 '좋은 단어' 개수를 세는 것을 도와주자.
> 
> 첫째 줄에 단어의 수 N이 주어진다. (1 ≤ N ≤ 100)
> 다음 N개 줄에는 A와 B로만 이루어진 단어가 한 줄에 하나씩 주어진다. 단어의 길이는 2와 100,000사이이며, 모든 단어 길이의 합은 1,000,000을 넘지 않는다.
> 
> 첫째 줄에 좋은 단어의 수를 출력한다.

### 게임처럼 생각해보자
대충 저 좋은 단어라는게 같은 문자끼리 붙은걸 제거하고, 공백을 삭제하는 과정을 반복해 완전히 사라지는 문자의 구조다.
즉 ABBA라면 A~~BB~~A → ~~AA~~ → (공백) 이 되니 좋은 단어고,  
AABA는 ~~AA~~BA → BA 가 되니 좋은 단어가 아니다.
### 코드
```c++
#include <iostream>
#include <stack>
using namespace std;

int N, ans;//입력 수인 N과 답을 저장할 ans
string a;//대충 문자열 받을 곳

int main(){
	ios::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);
  //입출력구문
	cin >> N;//개수 입력받고
	while (N--) {//어차피 다른 인자값 쓸 일이 없으니 while문 간단히 돌린다
		cin >> a;//문자열 입력 받고
		if (a.length() % 2) continue;//이 문자열 길이가 홀수면 어차피 좋은 단어가 되긴 글렀으니 생략해준다
		else {//아니면 가능성을 검사
			stack <char> st;//문자열 스택을 만들고
			for (int i = 0; i < a.length(); i++) {//단어의 각 문자에 대해
				if (!st.empty() && st.top() == a[i]) {//스택이 있고 해당 인덱스의 문자가 스택 맨 위의 문자와 일치한다면
					st.pop();//스택 맨 위를 날리고
					continue;//삽입하지 않고 생략
				}
				st.push(a[i]);//아니면 스택에 새로 문자를 넣어준다
			}
			if (st.empty()) ans++;//스택이 빈 경우면 모든 문자가 상쇄되는 경우이므로 카운트해주고
		}
	}
	cout << ans;//출력
}
```
### 해설
일단 스택 자료구조를 이용해, 단어의 각 문자를 하나씩 쌓아가면서 제거가 되는지 판단한다.  
같은거 2개가 바로 붙어서 나온다면 나오자마자 제거될 거고, 떨어져서 나와도 저놈의 좋은 단어 특성상  
어딘가에선 붙어 나오는 같은거 2개는 제거되면서 안 쌓이니까 스택에 남아있는 식별자와 붙어 떨어져 나갈 것이다.  
단어가 길이가 홀수면 가망이 없으니 생략하고, 아니면 이 작업을 단어 길이만큼 해주면 된다.
