---
title: 백준 12100번 2048 (Easy)
layout: post
tags: [cpp]
---
### 문제 개요
> 2048 게임은 4×4 크기의 보드에서 혼자 즐기는 재미있는 게임이다.  
> 이 게임에서 한 번의 이동은 보드 위에 있는 전체 블록을 상하좌우 네 방향 중 하나로 이동시키는 것이다. 이때, 같은 값을 갖는 두 블록이 충돌하면 두 블록은 하나로 합쳐지게 된다. 한 번의 이동에서 이미 합쳐진 블록은 또 다른 블록과 다시 합쳐질 수 없다. (실제 게임에서는 이동을 한 번 할 때마다 블록이 추가되지만, 이 문제에서 블록이 추가되는 경우는 없다)
> 이 문제에서 다루는 2048 게임은 보드의 크기가 N×N 이다. 보드의 크기와 보드판의 블록 상태가 주어졌을 때, 최대 5번 이동해서 만들 수 있는 가장 큰 블록의 값을 구하는 프로그램을 작성하시오.
> 
> 첫째 줄에 보드의 크기 N (1 ≤ N ≤ 20)이 주어진다. 둘째 줄부터 N개의 줄에는 게임판의 초기 상태가 주어진다. 0은 빈 칸을 나타내며, 이외의 값은 모두 블록을 나타낸다. 블록에 쓰여 있는 수는 2보다 크거나 같고, 1024보다 작거나 같은 2의 제곱꼴이다. 블록은 적어도 하나 주어진다.
> 
> 최대 5번 이동시켜서 얻을 수 있는 가장 큰 블록을 출력한다.

### 구현이 귀찮다
움직임의 조건과 분기가 꽤 많아 귀찮긴 하지만 기본적으로 백트래킹만 잘 해주면 메모리나 시간 제한 자체는 널널한 문제다.  
일단 너무 더러워지지 않는 선에서 정리해 봤다.
### 코드
```c++
#include <iostream>
#include <vector>
#include <deque>//이동부에 덱을 이용해 합치기와 재배치를 구현
using namespace std;

int N, maxx;
vector<vector<int>> board;//재할당이 편한 벡터로 보드 선언

void move(int cnt) {//패러미터에 현재 시도 횟수
    if (cnt == 5) {//5회에 달하면
        for (int i = 0; i < N; i++) for (int j = 0; j < N; j++) maxx = max(maxx, board[i][j]);//전체 보드에서 최댓값을 찾음
        return;
    }
    vector<vector<int>> bb = board;//전부 다 빠꾸하긴 귀찮으니 그냥 원본 보드 상태를 일단 저장
    for (int k = 0; k < 4; k++) {//상하좌우에 대해
        vector<deque<int>> rows(N);//단일 행 또는 열을 기준으로 잡게 된다면, 이동 후의 모습은 한쪽에 숫자가 몰리고 나머지는 비는 형태. 이걸 덱으로 구현
        int start = k & 1 ? N - 1 : 0, end = k & 1 ? -1 : N, delta = k & 1 ? -1 : 1;//양의 방향으로의 이동인지 음의 방향으로의 이동인지 판단해 시작점, 끝점, 델타값 설정
        for (int i = 0; i < N; i++) {//모든 행/열에 대해
            bool flg = true;//합치기 가능 여부를 판별할 이진 변수. 초기값은 가능
            for (int j = start; j != end; j += delta) {//시작점에서 끝점까지 델타값만큼 진행하며
                int tmp = k > 1 ? board[i][j] : board[j][i];//횡방향 이동인지 종방향 이동인지 판별해 다음 좌표 선정
                if (tmp) {//해당 좌표값이 0이 아닐때
                    if (flg && !rows[i].empty() && rows[i].back() == tmp) {//합칠 수 있는 상황이면
                        rows[i].pop_back();//덱 맨 뒤의 원소를 제거
                        tmp *= 2;//들어갈 값은 합쳐지니 2배로
                        flg = false;//다음번엔 합쳐지지 못하게 불가능으로 설정
                    }
                    else flg = true;//그 외의 경우 일단 합쳐질 수 있게 변수 설정
                    rows[i].push_back(tmp);//값을 행/열 덱에 넣어줌
                }
            }
        }
        for (int i = 0; i < N; i++) for (int j = start; j != end; j += delta) {//아까와 같은 방식으로 모든 좌표에 대해
            int& ptr = k > 1 ? board[i][j] : board[j][i];//횡/종 방향을 판별해 목적지 포인터 설정
            if (!rows[i].empty()) {//해당 행/렬의 덱에 원소가 있다면
                ptr = rows[i].front();//목적지에 맨 앞 원소를 넣어주고
                rows[i].pop_front();//맨 앞 원소 날림
            }
            else ptr = 0;//덱이 빈 경우 나머진 전부 0으로 채움
        }
        move(cnt + 1);//변경된 상태로부터 다시 탐색 
        board = bb;//탐색이 끝나면 보드 상태를 되돌림
    }
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin >> N;
    board.assign(N, vector<int>(N));//입력받은 사이즈에 따라 벡터 재설정
    for (int i = 0; i < N; i++)for (int j = 0; j < N; j++) cin >> board[i][j];//보드 전부 입력받음
    move(0);//초기 시점으로부터 탐색
    cout << maxx;
}
```
### 여담
합쳐짐을 구현함에 있어서, 같은 값 연속일때 전부 합치도록 구현하면 걸리도록 저격 TC가 악랄하게 들어있다.  
신경 써서 구현해줘야 했다.
